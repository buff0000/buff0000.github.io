<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SolidityÁºñÁ®ãËØ≠Ë®ÄÔºà13Ôºâ--Âú∞ÂùÄÔºàAddressÔºâ]]></title>
    <url>%2F2019%2F07%2F22%2FSolidity%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%8813%EF%BC%89-%E5%9C%B0%E5%9D%80%EF%BC%88Address%EF%BC%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[SolidityÁºñÁ®ãËØ≠Ë®ÄÔºà12Ôºâ--ÁªìÊûÑ‰Ωìstruct]]></title>
    <url>%2F2019%2F07%2F22%2FSolidity%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%8812%EF%BC%89-%E7%BB%93%E6%9E%84%E4%BD%93struct%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[SolidityÁºñÁ®ãËØ≠Ë®ÄÔºà11Ôºâ--Êûö‰∏æenum]]></title>
    <url>%2F2019%2F07%2F22%2FSolidity%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%8811%EF%BC%89-%E6%9E%9A%E4%B8%BEenum%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[SolidityÁºñÁ®ãËØ≠Ë®ÄÔºà10Ôºâ--ÂçÅÂÖ≠ËøõÂà∂‰∏≤]]></title>
    <url>%2F2019%2F07%2F22%2FSolidity%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%8810%EF%BC%89-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E4%B8%B2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[SolidityÁºñÁ®ãËØ≠Ë®ÄÔºà9Ôºâ--mapping]]></title>
    <url>%2F2019%2F07%2F22%2FSolidity%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%889%EF%BC%89-mapping%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[SolidityÁºñÁ®ãËØ≠Ë®ÄÔºà8Ôºâ--Â≠óËäÇÊï∞ÁªÑ]]></title>
    <url>%2F2019%2F07%2F22%2FSolidity%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%888%EF%BC%89-%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[SolidityÁºñÁ®ãËØ≠Ë®ÄÔºà7Ôºâ--Êï∞ÁªÑ]]></title>
    <url>%2F2019%2F07%2F22%2FSolidity%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%887%EF%BC%89-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[SolidityÁºñÁ®ãËØ≠Ë®ÄÔºà6Ôºâ--Â≠óÁ¨¶‰∏≤]]></title>
    <url>%2F2019%2F07%2F22%2FSolidity%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%886%EF%BC%89-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[SolidityÁºñÁ®ãËØ≠Ë®ÄÔºà5Ôºâ--Â∏ÉÂ∞îÂûãÂíåÊï¥Âûã]]></title>
    <url>%2F2019%2F07%2F22%2FSolidity%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%885%EF%BC%89-%E5%B8%83%E5%B0%94%E5%9E%8B%E5%92%8C%E6%95%B4%E5%9E%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[SolidityÁºñÁ®ãËØ≠Ë®ÄÔºà4Ôºâ--HelloWorld]]></title>
    <url>%2F2019%2F07%2F22%2FSolidity%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%884%EF%BC%89-HelloWorld%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[SolidityÂºÄÂèëÁéØÂ¢ÉÔºà3Ôºâ--Mist]]></title>
    <url>%2F2019%2F07%2F22%2FSolidity%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%883%EF%BC%89-Mist%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[SolidityÂºÄÂèëÁéØÂ¢ÉÔºà2Ôºâ--Remix-IDE]]></title>
    <url>%2F2019%2F07%2F22%2FSolidity%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%882%EF%BC%89-Remix-IDE%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[SolidityÂºÄÂèëÁéØÂ¢ÉÔºà1Ôºâ--Âø´ÈÄüÊê≠Âª∫‰ª•Â§™ÂùäÁßÅÈìæ]]></title>
    <url>%2F2019%2F07%2F22%2FSolidity%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%881%EF%BC%89-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[GO-HPBÊ∫êÁ†ÅËß£ËØª--work.go]]></title>
    <url>%2F2019%2F07%2F21%2FGO-HPB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-work-go%2F</url>
    <content type="text"><![CDATA[Âú®‰∫ÜËß£HPBÊåÅ‰πÖÂåñÂå∫ÂùóÁöÑÊó∂ÂÄôÔºåÂú®levelDBÁöÑputÊñπÊ≥ï‰∏≠ÊâìÂç∞‰∫Ü‰∏Ä‰∏ãË∞ÉÁî®Ê†àÔºåÂèëÁé∞‰∏ÄÂÖ±Ë∞ÉÁî®‰∫Ü5Ê¨°ÔºåÊó•ÂøóÂ¶Ç‰∏ãÔºö 12345678910INFO [01-27|22:54:54] HPB : Successfully sealed new block number -&gt; =2 hash -&gt; =8060c5‚Ä¶80af4c difficulty -&gt; =1ERROR[01-27|22:54:54] HPB : mdatabase %s=&quot;goroutine 56 [running]:\nruntime/debug.Stack(0xc001ad3940, 0x41167f, 0x10)/usr/local/go/src/runtime/debug/stack.go:24 +0xa7\ngithub.com/hpb-project/go-hpb/blockchain/storage.(*LMDBDatabase).Put(0xc0001452b0, 0xc0018ab7a0, 0x2a, 0x30, 0xc0017f9c20, 0x1, 0x1, 0x0, 0x0)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/blockchain/storage/mdatabase.go:65 +0x42\ngithub.com/hpb-project/go-hpb/blockchain.WriteTd(0x7fd9a9b5cbf0, 0xc0001452b0, 0x7eef19c735c56080, 0x558872de29feac8, 0x69fb026f2a700595, 0x4caf80c4389aafac, 0x2, 0xc001ac7de0, 0x0, 0x0)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/blockchain/database_util.go:481 +0x212\ngithub.com/hpb-project/go-hpb/blockchain.(*HeaderChain).WriteTd(0xc00012a400, 0x7eef19c735c56080, 0x558872de29feac8, 0x69fb026f2a700595, 0x4caf80c4389aafac, 0x2, 0xc001ac7de0, 0x0, 0x0)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/blockchain/headerchain.go:333 +0xa5\ngithub.com/hpb-project/go-hpb/blockchain.(*BlockChain).WriteBlockAndState(0xc000056e00, 0xc001a83680, 0x0, 0x0, 0x0, 0xc001cc4690, 0x0, 0x0, 0x0)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/blockchain/blockchain.go:846 +0x381\ngithub.com/hpb-project/go-hpb/worker.(*worker).handlerSelfMinedBlock(0xc0000ec360)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/worker/worker.go:345 +0x22e\ncreated by github.com/hpb-project/go-hpb/worker.newWorker/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/worker/worker.go:165 +0x385\n&quot;ERROR[01-27|22:54:54] HPB : mdatabase put=1 123456789ERROR[01-27|22:54:54] HPB : mdatabase %s=&quot;goroutine 56 [running]:\nruntime/debug.Stack(0x479eae, 0x41167f, 0x431301)/usr/local/go/src/runtime/debug/stack.go:24 +0xa7\ngithub.com/hpb-project/go-hpb/blockchain/storage.(*LMDBDatabase).Put(0xc0001452b0, 0xc0017f9dd0, 0xa, 0x10, 0xc001a6df60, 0x20, 0x20, 0x0, 0x0)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/blockchain/storage/mdatabase.go:65 +0x42\ngithub.com/hpb-project/go-hpb/blockchain.WriteCanonicalHash(0x7fd9a9b5cbf0, 0xc0001452b0, 0x7eef19c735c56080, 0x558872de29feac8, 0x69fb026f2a700595, 0x4caf80c4389aafac, 0x2, 0x30, 0xc0017f9d98)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/blockchain/database_util.go:406 +0x156\ngithub.com/hpb-project/go-hpb/blockchain.(*BlockChain).insert(0xc000056e00, 0xc001a83680)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/blockchain/blockchain.go:501 +0x1db\ngithub.com/hpb-project/go-hpb/blockchain.(*BlockChain).WriteBlockAndState(0xc000056e00, 0xc001a83680, 0x0, 0x0, 0x0, 0xc001cc4690, 0x1, 0x0, 0x0)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/blockchain/blockchain.go:890 +0x80e\ngithub.com/hpb-project/go-hpb/worker.(*worker).handlerSelfMinedBlock(0xc0000ec360)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/worker/worker.go:345 +0x22e\ncreated by github.com/hpb-project/go-hpb/worker.newWorker/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/worker/worker.go:165 +0x385\n&quot;ERROR[01-27|22:54:54] HPB : mdatabase put=32 123456789ERROR[01-27|22:54:54] HPB : mdatabase %s=&quot;goroutine 56 [running]:\nruntime/debug.Stack(0x20, 0x0, 0x0)/usr/local/go/src/runtime/debug/stack.go:24 +0xa7\ngithub.com/hpb-project/go-hpb/blockchain/storage.(*LMDBDatabase).Put(0xc0001452b0, 0x1983068, 0x9, 0x9, 0xc001a6dfc0, 0x20, 0x20, 0x0, 0x0)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/blockchain/storage/mdatabase.go:65 +0x42\ngithub.com/hpb-project/go-hpb/blockchain.WriteHeadBlockHash(0x7fd9a9b5cbf0, 0xc0001452b0, 0x7eef19c735c56080, 0x558872de29feac8, 0x69fb026f2a700595, 0x4caf80c4389aafac, 0x2, 0x0)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/blockchain/database_util.go:422 +0x9f\ngithub.com/hpb-project/go-hpb/blockchain.(*BlockChain).insert(0xc000056e00, 0xc001a83680)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/blockchain/blockchain.go:504 +0x2f0\ngithub.com/hpb-project/go-hpb/blockchain.(*BlockChain).WriteBlockAndState(0xc000056e00, 0xc001a83680, 0x0, 0x0, 0x0, 0xc001cc4690, 0x1, 0x0, 0x0)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/blockchain/blockchain.go:890 +0x80e\ngithub.com/hpb-project/go-hpb/worker.(*worker).handlerSelfMinedBlock(0xc0000ec360)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/worker/worker.go:345 +0x22e\ncreated by github.com/hpb-project/go-hpb/worker.newWorker/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/worker/worker.go:165 +0x385\n&quot;ERROR[01-27|22:54:54] HPB : mdatabase put=32 12345678910ERROR[01-27|22:54:54] HPB : mdatabase %s=&quot;goroutine 56 [running]:\nruntime/debug.Stack(0xc001ad3868, 0x563c36, 0xc001d4e060)/usr/local/go/src/runtime/debug/stack.go:24 +0xa7\ngithub.com/hpb-project/go-hpb/blockchain/storage.(*LMDBDatabase).Put(0xc0001452b0, 0x1983098, 0xa, 0xa, 0xc001d4e080, 0x20, 0x20, 0x0, 0x0)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/blockchain/storage/mdatabase.go:65 +0x42\ngithub.com/hpb-project/go-hpb/blockchain.WriteHeadHeaderHash(0x7fd9a9b5cbf0, 0xc0001452b0, 0x7eef19c735c56080, 0x558872de29feac8, 0x69fb026f2a700595, 0x4caf80c4389aafac, 0x9ca0cf, 0xc001cd65d0)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/blockchain/database_util.go:414 +0x9f\ngithub.com/hpb-project/go-hpb/blockchain.(*HeaderChain).SetCurrentHeader(0xc00012a400, 0xc001245400)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/blockchain/headerchain.go:396 +0xaa\ngithub.com/hpb-project/go-hpb/blockchain.(*BlockChain).insert(0xc000056e00, 0xc001a83680)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/blockchain/blockchain.go:511 +0x3da\ngithub.com/hpb-project/go-hpb/blockchain.(*BlockChain).WriteBlockAndState(0xc000056e00, 0xc001a83680, 0x0, 0x0, 0x0, 0xc001cc4690, 0x1, 0x0, 0x0)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/blockchain/blockchain.go:890 +0x80e\ngithub.com/hpb-project/go-hpb/worker.(*worker).handlerSelfMinedBlock(0xc0000ec360)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/worker/worker.go:345 +0x22e\ncreated by github.com/hpb-project/go-hpb/worker.newWorker/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/worker/worker.go:165 +0x385\n&quot;ERROR[01-27|22:54:54] HPB : mdatabase put=32 123456789ERROR[01-27|22:54:54] HPB : mdatabase %s=&quot;goroutine 56 [running]:\nruntime/debug.Stack(0xc001d4e100, 0xc001d35500, 0xc001d4e0e0)/usr/local/go/src/runtime/debug/stack.go:24 +0xa7\ngithub.com/hpb-project/go-hpb/blockchain/storage.(*LMDBDatabase).Put(0xc0001452b0, 0x1982cb0, 0x8, 0x8, 0xc001d4e120, 0x20, 0x20, 0x0, 0x0)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/blockchain/storage/mdatabase.go:65 +0x42\ngithub.com/hpb-project/go-hpb/blockchain.WriteHeadFastBlockHash(0x7fd9a9b5cbf0, 0xc0001452b0, 0x7eef19c735c56080, 0x558872de29feac8, 0x69fb026f2a700595, 0x4caf80c4389aafac, 0x0, 0x0)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/blockchain/database_util.go:430 +0x9f\ngithub.com/hpb-project/go-hpb/blockchain.(*BlockChain).insert(0xc000056e00, 0xc001a83680)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/blockchain/blockchain.go:513 +0x455\ngithub.com/hpb-project/go-hpb/blockchain.(*BlockChain).WriteBlockAndState(0xc000056e00, 0xc001a83680, 0x0, 0x0, 0x0, 0xc001cc4690, 0x1, 0x0, 0x0)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/blockchain/blockchain.go:890 +0x80e\ngithub.com/hpb-project/go-hpb/worker.(*worker).handlerSelfMinedBlock(0xc0000ec360)/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/worker/worker.go:345 +0x22e\ncreated by github.com/hpb-project/go-hpb/worker.newWorker/home/buff/workspace/goland/src/github.com/hpb-project/go-hpb/build/workspace/src/github.com/hpb-project/go-hpb/worker/worker.go:165 +0x385\n&quot;ERROR[01-27|22:54:54] HPB : mdatabase put=32 11‚Äôatom-workspace‚Äô: ‚Äòctrl-v‚Äô: ‚Äòmarkdown-img-paste:paste‚Äô !ls../images/SubscribeTxPreEvent.png ÈÄöËøáÊó•ÂøóÂèëÁé∞ÂÖ•Âè£ÈÉΩÊòØworker.goËøô‰∏™Êñá‰ª∂‰∏≠ÁöÑ]]></content>
      <categories>
        <category>HPBÊ∫êÁ†ÅËß£ËØª</category>
      </categories>
      <tags>
        <tag>HPB</tag>
        <tag>Âå∫ÂùóÈìæ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GO-HPBÊ∫êÁ†ÅËß£ËØª--PRCÊúçÂä°ÂêØÂä®]]></title>
    <url>%2F2019%2F07%2F21%2FGO-HPB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-PRC%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[RPCÊúçÂä°ÊòØÂú®ËäÇÁÇπÂêØÂä®ÁöÑÊó∂ÂÄôÈÄöËøáÂèÇÊï∞‚Äìrpcaddr 0.0.0.0 ‚Äìrpcport 8541Êù•ÊåáÂÆöÁöÑÔºåÂêØÂä®‰ª£Á†ÅÊòØÔºö 12hpbnode.SetNodeAPI()hpbnode.Hpbrpcmanager.Start(hpbnode.RpcAPIs) ÂÖ∂‰∏≠SetNodeAPIÊòØÊääÊâÄÊúâÁöÑAPIÂÆö‰πâ‰ª•[]rpc.APIÁöÑÊï∞ÊçÆÁ±ªÂûã‰øùÂ≠òhpbnode.RpcAPIsÔºåÁÑ∂ÂêéÂÜç‰º†ÁªôStartÊñπÊ≥ï„ÄÇAPIÁöÑÁªìÊûÑÂ¶Ç‰∏ãÔºåÂÖ∂‰∏≠public‰∏∫falseÁöÑËØùÊòØ‰∏ç‰ºöÂèëÂ∏ÉÂá∫Âéª‰∫Ü„ÄÇ 123456type API struct &#123; Namespace string // namespace under which the rpc methods of Service are exposed Version string // api version for DApp's Service interface&#123;&#125; // receiver instance which holds the methods Public bool // indication if the methods must be considered safe for public use&#125; ÁÑ∂ÂêéÂêØÂä®RPCÊúçÂä°ÔºåÂèØ‰ª•ÁúãÂà∞‰∏ÄÂÖ±ÊåáÂÆö‰∫Ü‰∏âÁßçÂΩ¢ÂºèÁöÑÊúçÂä°ÂèÇÊï∞ÔºåÂàÜÂà´ÊòØipc„ÄÅhttp„ÄÅwsÔºåipcÊòØËøõÁ®ãÈó¥ÈÄö‰ø°ÔºåÂú®Âêå‰∏ÄÊú∫Âô®‰∏äËøõË°åÁöÑÂÜÖÂ≠òÂÖ±‰∫´ÊñπÂºèÈÄö‰ø°ÔºåÁî±‰∫é‰∏çÁªèËøáÁΩëÂç°ËΩ¨ËæìÊï∞ÊçÆÔºåÊâÄ‰ª•ÂèØ‰ª•ËäÇÁúÅÁΩëÁªúËµÑÊ∫êÔºõhttpÂ∞±ÊòØÊàë‰ª¨ÈÄöËøáweb3Êé•Âè£Ë∞ÉÁî®ÁöÑÈÄö‰ø°ÊúçÂä°ÔºåwsÊòØWebServiceÊòØ‰∏ÄÁßç‰∏•Ê†ºÂÆö‰πâÊä•ÊñáÊ†ºÂºèÁöÑÂçèËÆÆÔºåÂ∫ïÂ±Ç‰πüÊòØÂü∫‰∫éhttpÁöÑÔºåËøôÈáåÊàë‰ª¨‰∏ªË¶ÅÁúã‰∏ãhttpÊúçÂä°„ÄÇÂ¶ÇÊûúÂêéÂêØÂä®ÁöÑÊúçÂä°Âá∫Áé∞ÂºÇÂ∏∏ÔºåÂàôÈúÄË¶ÅÊääÊâÄÊúâÂ∑≤ÂêØÂä®ÁöÑÊúçÂä°ÂÅúÊ≠¢ÊéâÔºåÂπ∂ËøîÂõû„ÄÇ 1234567891011121314151617181920212223242526func (prm *RpcManager)Start(apis []API ) error &#123; config :=config.GetHpbConfigInstance() // for-test log.Debug("Para from config.","IpcEndpoint",config.Network.IpcEndpoint,"HttpEndpoint",config.Network.HttpEndpoint,"WsEndpoint",config.Network.WsEndpoint) prm.rpcmgr = &amp;RpcMgr&#123; ipcEndpoint: config.Network.IpcEndpoint, httpEndpoint: config.Network.HttpEndpoint, wsEndpoint: config.Network.WsEndpoint, httpCors: config.Network.HTTPCors, httpModules: config.Network.HTTPModules, httpVirtualHosts:config.Network.HTTPVirtualHosts, httpTimeouts: config.Network.HTTPTimeouts, wsOrigins: config.Network.WSOrigins, wsModules: config.Network.WSModules, wsExposeAll: config.Network.WSExposeAll, &#125; if err := prm.rpcmgr.startRPC(apis); err != nil &#123; log.Error("start rpc error","reason",err) &#125; return nil&#125; startRPCÊñπÊ≥ï‰∏≠ÊåâÁÖßÂÖàÂêéÈ°∫Â∫èÂàÜÂà´ÂêØÂä®‰∫ÜÂõõÁßçÂΩ¢ÂºèÁöÑÊúçÂä°ÔºåÂ§ö‰∫Ü‰∏ÄÁßçInProcÔºåËøô‰∏™ÊòØËøõÁ®ãÂÜÖÈÄö‰ø°ÔºàÂÖ∑‰Ωì‰ΩøÁî®ËøòÊ≤°Á†îÁ©∂Ôºâ„ÄÇËøôÈáåÊàë‰ª¨Â∞±Áúã‰∏Ä‰∏ãstartHTTPÁöÑÂêØÂä®ËøáÁ®ã„ÄÇ 1234567891011121314151617181920212223242526272829// startRPC is a helper method to start all the various RPC endpoint during node// startup. It's not meant to be called at any time afterwards as it makes certain// assumptions about the state of the node.func (n *RpcMgr) startRPC(apis []API) error &#123; // Gather all the possible APIs to surface n.rpcAPIs = apis // Start the various API endpoints, terminating all in case of errors if err := n.startInProc(apis); err != nil &#123; return err &#125; if err := n.startIPC(apis); err != nil &#123; n.stopInProc() return err &#125; if err := n.startHTTP(n.httpEndpoint, apis, n.httpModules, n.httpCors, n.httpVirtualHosts, n.httpTimeouts); err != nil &#123; n.stopIPC() n.stopInProc() return err &#125; if err := n.startWS(n.wsEndpoint, apis, n.wsModules, n.wsOrigins, n.wsExposeAll); err != nil &#123; n.stopHTTP() n.stopIPC() n.stopInProc() return err &#125; // All API endpoints started successfully return nil&#125; Âú®StartHTTPEndpointÊñπÊ≥ï‰∏≠ÔºåmodulesÂ∞±ÊòØÂú®ÂêØÂä®ÁöÑÊó∂ÂÄôÈÄöËøáÂèÇÊï∞‚Äìrpcapi hpb,web3,admin,txpool,debug,personal,netÊåáÂÆöÁöÑÔºåË°®Á§∫ÂêØÂä®ÁöÑÊ®°ÂùóÔºåRPCÂú®ÂêØÂä®ÁöÑÊó∂ÂÄô‰ºöÊ£ÄÊü•Á®ãÂ∫èÊâÄÂÆöÁöÑAPIÊòØÂê¶Âú®modules‰∏≠ÔºåÂè™ÊúâÂú®ÁöÑÊâç‰ºöÂêØÂä®ÔºåÂè¶Â§ñËøòÊúâ‰∏™Êù°‰ª∂Â∞±ÊòØapiÊòØPublicÁöÑ„ÄÇNewHTTPServerÊñπÊ≥ïÂêØÂä®ÊúçÂä°ÔºåÂÖ∂‰∏≠corsÂèÇÊï∞ÊòØË∑®ÂüüÂüüÂêç 12345678910111213141516171819202122232425262728// StartHTTPEndpoint starts the HTTP RPC endpoint, configured with cors/vhosts/modulesfunc StartHTTPEndpoint(endpoint string, apis []API, modules []string, cors []string, vhosts []string, timeouts config.HTTPTimeouts) (net.Listener, *Server, error) &#123; // Generate the whitelist based on the allowed modules whitelist := make(map[string]bool) for _, module := range modules &#123; whitelist[module] = true &#125; // Register all the APIs exposed by the services handler := NewServer() for _, api := range apis &#123; if whitelist[api.Namespace] || (len(whitelist) == 0 &amp;&amp; api.Public) &#123; if err := handler.RegisterName(api.Namespace, api.Service); err != nil &#123; return nil, nil, err &#125; log.Debug("HTTP registered", "namespace", api.Namespace) &#125; &#125; // All APIs registered, start the HTTP listener var ( listener net.Listener err error ) if listener, err = net.Listen("tcp", endpoint); err != nil &#123; return nil, nil, err &#125; go NewHTTPServer(cors, vhosts, timeouts, handler).Serve(listener) return listener, handler, err&#125;]]></content>
      <categories>
        <category>HPBÊ∫êÁ†ÅËß£ËØª</category>
      </categories>
      <tags>
        <tag>HPB</tag>
        <tag>Âå∫ÂùóÈìæ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GO-HPBÊ∫êÁ†ÅËß£ËØª--P2PÂêØÂä®]]></title>
    <url>%2F2019%2F07%2F21%2FGO-HPB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-P2P%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[P2PÂêØÂä®ÊòØÂú®ËäÇÁÇπÂêØÂä®ÁöÑÊó∂ÂÄôËøõË°åÁöÑÔºåÂêØÂä®‰ª£Á†ÅÊòØhpbnode.Hpbpeermanager.Start(hpbnode.hpberbase) 123456789101112131415161718192021222324252627282930func (hpbnode *Node) Start(conf *config.HpbConfig) error &#123; if config.GetHpbConfigInstance().Node.TestCodeParam == 1 &#123; consensus.SetTestParam() &#125; hpbnode.startBloomHandlers() err := hpbnode.WorkerInit(conf) if err != nil &#123; log.Error("Worker init failed", ":", err) return err &#125; if hpbnode.Hpbsyncctr == nil &#123; log.Error("syncctrl is nil") return errors.New("synctrl is nil") &#125; hpbnode.Hpbsyncctr.Start() retval := hpbnode.Hpbpeermanager.Start(hpbnode.hpberbase) if retval != nil &#123; log.Error("Start hpbpeermanager error") return errors.New(`start peermanager error ".ipc"`) &#125; hpbnode.SetNodeAPI() hpbnode.Hpbrpcmanager.Start(hpbnode.RpcAPIs) hpbnode.Hpbtxpool.Start() return nil&#125; Âú®StartÊñπÊ≥ï‰∏≠ ÈÖçÁΩÆÁΩëÁªúÂêØÂä®ÂèÇÊï∞‰ø°ÊÅØ Ê≥®ÂÜåNodeMsgÊ∂àÊÅØÂ§ÑÁêÜÂáΩÊï∞ ËÆæÁΩÆÊú¨Âú∞ËäÇÁÇπÁöÑÁ±ªÂûãÂàÜÂà´ÊòØÂÄôÈÄâËäÇÁÇπ„ÄÅÂºïÂØºËäÇÁÇπ„ÄÅÂêåÊ≠•ËäÇÁÇπ ÂêØÂä®ÊúçÂä°(prm.server.Start()) Ê£ÄÊü•Êú¨Âú∞ËäÇÁÇπÊòØ‰∏çÊòØÂú®BootstrapNodesÂàóË°®‰∏≠Ôºå‰πüÂ∞±ÊòØÁ®ãÂ∫èÈ¶ñÊ¨°ÂÆâË£ÖÁöÑÊó∂ÂÄôËøûÊé•ÁöÑËäÇÁÇπ„ÄÇ ÂêØÂä®iperfÂ∏¶ÂÆΩÊµãËØïÊúçÂä°ÔºåËØ•Á´ØÂè£ÊòØpeerÁöÑÁ´ØÂè£Âä†100„ÄÇiperfÁöÑÂêØÂä®ÊòØÈÄöËøáË∞ÉÁî®shellÂëΩ‰ª§Êù•ÂêØÊù•ÁöÑÔºåiperfÂ∫îÁî®ÂåÖÂ∞±Âú®ghpb-binÂÆâË£ÖÁõÆÂΩï‰∏ã„ÄÇÂëΩ‰ª§ÊòØÔºöbin/bash iperf3 -s -p port Â¶ÇÊûúÊòØÊåñÁüøËäÇÁÇπÁöÑËØùÔºåÂºÇÊ≠•ÂêØÂä®iperfÂ∏¶ÂÆΩÊµãËØïÂÆ¢Êà∑Á´Ø Â¶ÇÊûúbootËäÇÁÇπÁöÑËØùÔºåÈúÄË¶ÅËß£Êûê‰∏Ä‰∏ãbinding.jsonÊñá‰ª∂ÔºåËøô‰∏™Áî®Êù•ÊåáÂÆöÂêØÂä®Êó∂ÂèØ‰ª•ËøûÊé•ÁöÑpeerÂú∞ÂùÄ1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677func (prm *PeerManager) Start(coinbase common.Address) error &#123; config := config.GetHpbConfigInstance() prm.server.Config = Config&#123; NAT: config.Network.NAT, Name: config.Network.Name, TestMode: config.Node.TestMode == 1, PrivateKey: config.Node.PrivateKey, NetworkId: config.Node.NetworkId, ListenAddr: config.Network.ListenAddr, NetRestrict: config.Network.NetRestrict, NodeDatabase: config.Network.NodeDatabase, BootstrapNodes: config.Network.BootstrapNodes, EnableMsgEvents: config.Network.EnableMsgEvents, Protocols: prm.hpbpro.Protocols(), &#125; prm.server.Config.CoinBase = coinbase log.Info("Set coinbase address by start", "address", coinbase.String()) if coinbase.String() == "0x0000000000000000000000000000000000000000" &#123; panic("coinbase address is nil.") &#125; prm.hpbpro.networkId = prm.server.NetworkId prm.hpbpro.regMsgProcess(ReqNodesMsg, HandleReqNodesMsg) prm.hpbpro.regMsgProcess(ResNodesMsg, HandleResNodesMsg) prm.hpbpro.regMsgProcess(ReqBWTestMsg, prm.HandleReqBWTestMsg) prm.hpbpro.regMsgProcess(ResBWTestMsg, prm.HandleResBWTestMsg) copy(prm.server.Protocols, prm.hpbpro.Protocols()) localType := discover.PreNode if config.Network.RoleType == "bootnode" &#123; localType = discover.BootNode &#125; else if config.Network.RoleType == "synnode" &#123; localType = discover.SynNode &#125; prm.SetLocalType(localType) log.Info("Set Init Local Type by p2p", "type", localType.ToString()) if err := prm.server.Start(); err != nil &#123; log.Error("Hpb protocol", "error", err) return err &#125; //////////////////////////////////////////////////////////////////////////////////////// //for bootnode check self := prm.server.Self() for _, n := range config.Network.BootstrapNodes &#123; if self.ID == n.ID &amp;&amp; prm.server.localType != discover.BootNode &#123; panic("Need BOOTNODE flag.") &#125; &#125; ///////////////////////////////////////////////////////////////////////////////////////// add, _ := net.ResolveUDPAddr("udp", prm.server.ListenAddr) prm.iport = add.Port + 100 log.Debug("Iperf server start", "port", prm.iport) prm.startServerBW(strconv.Itoa(prm.iport)) if prm.server.localType != discover.BootNode &amp;&amp; prm.server.localType != discover.SynNode &#123; go prm.startClientBW() &#125; ///////////////////////////////////////////////////////////////////////////////////////// //for bing info if prm.server.localType == discover.BootNode &#123; filename := filepath.Join(config.Node.DataDir, bindInfoFileName) log.Debug("bootnode load bindings", "filename", filename) prm.parseBindInfo(filename) &#125; return nil&#125; prm.server.Start()ÊñπÊ≥ïÊòØÁî®Êù•ÂêØÂä®P2PÊúçÂä°ÁöÑ„ÄÇ Âà§Êñ≠ÊúçÂä°ÊòØÂê¶ÂêØÂä® ÂàõÂª∫RLPXÔºåÂÆûÁé∞ÁΩëÁªúÊï∞ÊçÆ‰º†ËæìÂä†ÂØÜÔºåËøôÈáåÊúâ‰∏™ÁøªËØëÊñáÊ°£ÂèØ‰ª•ËØ¶ÁªÜ‰∫ÜËß£‰∏ã ÂàùÂßãÂåñ‰∏Ä‰∫õServerÁöÑÂ±ûÊÄß ÂêØÂä®UDPÊúçÂä°Ôºå‰∏ªË¶ÅÊòØÁî®Êù•ÂèëÁé∞ËäÇÁÇπÁöÑ ËÆæÁΩÆbootËäÇÁÇπÂú∞ÂùÄÔºåÊ∑ªÂä†Âà∞table‰∏≠ ÊåáÂÆöËá™Â∑±ÁöÑÊè°ÊâãÂçèËÆÆ srv.startListening()ÂêØÂä®TCPÊúçÂä° ÂàõÂª∫newDialStateÂØπË±°ÔºåÂπ∂ÂºÇÊ≠•ËøêË°å123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// Start starts running the server.// Servers can not be re-used after stopping.func (srv *Server) Start() (err error) &#123; srv.lock.Lock() defer srv.lock.Unlock() if srv.running &#123; return errors.New("server already running") &#125; srv.running = true log.Info("Starting P2P networking") rand.Seed(time.Now().Unix()) // static fields if srv.PrivateKey == nil &#123; return fmt.Errorf("Server.PrivateKey must be set to a non-nil key") &#125; if srv.newTransport == nil &#123; srv.newTransport = newRLPX &#125; srv.quit = make(chan struct&#123;&#125;) srv.addpeer = make(chan *conn) srv.delpeer = make(chan peerDrop) srv.posthandshake = make(chan *conn) srv.addstatic = make(chan *discover.Node) srv.removestatic = make(chan *discover.Node) srv.peerOp = make(chan peerOpFunc) srv.peerOpDone = make(chan struct&#123;&#125;) srv.peerEvent = event.NewEvent() srv.delHist = new(dialHistory) srv.dialer = TCPDialer&#123;&amp;net.Dialer&#123;Timeout: defaultDialTimeout&#125;&#125; // node table ntab, ourend, err := discover.ListenUDP(srv.PrivateKey, srv.localType, srv.ListenAddr, srv.NAT, srv.NodeDatabase, srv.NetRestrict) if err != nil &#123; return err &#125; if err := ntab.SetFallbackNodes(srv.BootstrapNodes); err != nil &#123; return err &#125; srv.ntab = ntab // handshake srv.ourHandshake = &amp;protoHandshake&#123;Version: MsgVersion, Name: srv.Name, ID: discover.PubkeyID(&amp;srv.PrivateKey.PublicKey), End:ourend&#125; for _, p := range srv.Protocols &#123; srv.ourHandshake.Caps = append(srv.ourHandshake.Caps, p.cap()) &#125; srv.ourHandshake.CoinBase = srv.CoinBase if srv.ListenAddr == "" &#123; log.Error("P2P server start, listen address is nil") &#125; if err := srv.startListening(); err != nil &#123; return err &#125; ////////////////////////////////////////////////////////////////////////////////////////////// if srv.TestMode &#123; srv.parseSynnode() &#125; ////////////////////////////////////////////////////////////////////////////////////////////// log.Info("Server start with type.","NodeType",srv.localType.ToString()) dialer := newDialState(srv.StaticNodes, srv.BootstrapNodes, srv.ntab, srv.NetRestrict) srv.loopWG.Add(1) go srv.run(dialer) srv.running = true return nil&#125; Âú®startListeningÊñπÊ≥ï‰∏≠ÔºåÈ¶ñÂÖàÂºÄÂßãÁõëÂê¨Á´ØÂè£ÔºåÁÑ∂ÂêéËøõË°åÊé•Êî∂ËøûÊé•Â§ÑÁêÜÔºå‰∏ªË¶ÅÁúã‰∏ãsrv.listenLoop()ÊñπÊ≥ïÔºåÂè¶Â§ñËøòËøõË°å‰∫ÜNATËΩ¨Êç¢„ÄÇ maxAcceptConns=100ÂèÇÊï∞Ë°®Á§∫ÁöÑÊòØÊúÄÂ§ßÂèØÊè°ÊâãËøûÊé•Êï∞ÔºåÂπ∂‰∏çÊòØÂÆûÈôÖËøûÊé•Êï∞ÔºåÊØîÂ¶ÇËäÇÁÇπÂèØ‰ª•ÂêåÊó∂Âíå200‰∏™peerÂª∫Á´ãËøûÊé•Ôºå‰ΩÜÂú®Âêå‰∏ÄÊó∂Èó¥ÁÇπÔºåÂè™ËÉΩÂíå100peerËøõË°åÊè°Êâã„ÄÇÊâÄ‰ª•ÁúãÂà∞‰ª£Á†ÅÂàõÂª∫‰∫Ü100‰∏™slot‚Äú‰ø°Âè∑‚ÄùÔºåÊé•ÁùÄfor‰∏çÊñ≠ÁöÑÂèñslot‚Äú‰ø°Âè∑‚ÄùÔºåÁõ∏ÂΩì‰∫éÊ∂àËÄó‰∫Ü‰∏Ä‰∏™Ôºå‰ΩÜÊòØÂú®ÂàõÂª∫ÂÆåËøûÊé•‰πãÁöÑÂèàÂàõÂª∫‰∫Ü‰∏Ä‰∏™slot‚Äú‰ø°Âè∑‚Äù forÂæ™ÁéØ‰∏≠‰∏ªË¶ÅÊòØËé∑Âèñ‰∫ÜËøûÊé•ÔºåÁÑ∂ÂêéÂà§Êñ≠‰∏Ä‰∏ãÊòØ‰∏çÊòØÂèóÈôêÂú∞ÂùÄÔºàÈªëÂêçÂçïÔºâÔºåÂ¶ÇÊûú‰∏çÊòØÂ∞±ÂºÇÊ≠•ËøõË°åSetupConn1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980func (srv *Server) startListening() error &#123; // Launch the TCP listener. listener, err := net.Listen("tcp", srv.ListenAddr) if err != nil &#123; return err &#125; laddr := listener.Addr().(*net.TCPAddr) srv.ListenAddr = laddr.String() srv.listener = listener srv.loopWG.Add(1) go srv.listenLoop() // Map the TCP listening port if NAT is configured. if !laddr.IP.IsLoopback() &amp;&amp; srv.NAT != nil &#123; srv.loopWG.Add(1) go func() &#123; nat.Map(srv.NAT, srv.quit, "tcp", laddr.Port, laddr.Port, "hpb p2p") srv.loopWG.Done() &#125;() &#125; return nil&#125;// listenLoop runs in its own goroutine and accepts// inbound connections.func (srv *Server) listenLoop() &#123; defer srv.loopWG.Done() //log.Info("RLPx listener up", "self", srv.makeSelf(srv.listener)) // This channel acts as a semaphore limiting // active inbound connections that are lingering pre-handshake. // If all slots are taken, no further connections are accepted. tokens := maxAcceptConns slots := make(chan struct&#123;&#125;, tokens) for i := 0; i &lt; tokens; i++ &#123; slots &lt;- struct&#123;&#125;&#123;&#125; &#125; for &#123; // Wait for a handshake slot before accepting. &lt;-slots var ( fd net.Conn err error ) for &#123; fd, err = srv.listener.Accept() if tempErr, ok := err.(tempError); ok &amp;&amp; tempErr.Temporary() &#123; log.Debug("Temporary read error", "err", err) continue &#125; else if err != nil &#123; log.Debug("Read error", "err", err) return &#125; break &#125; // Reject connections that do not match NetRestrict. if srv.NetRestrict != nil &#123; if tcp, ok := fd.RemoteAddr().(*net.TCPAddr); ok &amp;&amp; !srv.NetRestrict.Contains(tcp.IP) &#123; log.Debug("Rejected conn (not whitelisted in NetRestrict)", "addr", fd.RemoteAddr()) fd.Close() slots &lt;- struct&#123;&#125;&#123;&#125; continue &#125; &#125; fd = newMeteredConn(fd, true) log.Info("Accepted connection", "addr", fd.RemoteAddr()) // Spawn the handler. It will give the slot back when the connection // has been established. go func() &#123; srv.SetupConn(fd, inboundConn, nil) slots &lt;- struct&#123;&#125;&#123;&#125; &#125;() &#125;&#125; Âú®SetupConn‰∏≠ Âà§Êñ≠ÊúçÂä°ÊòØ‰∏çÊòØÂêØÂä® ËøôË°å‰ª£Á†Å‰∏≠c := &amp;conn{fd: fd, transport: srv.newTransport(fd), flags: flags, cont: make(chan error)}ÂèØ‰ª•ÁúãÂà∞srv.newTransportËøô‰∏™ÂèÇÊï∞ÁöÑ‰º†ÂÖ•ÔºåÂÖ∂ÂÆûÂ∞±ÊòØ‰∏äËæπÁöÑRLPX„ÄÇ c.doEncHandshakeËøõË°åENCÊè°ÊâãÔºåÂÖ∑‰ΩìÂÆûÁé∞ÈÉΩÊòØRLPXÂÅöÁöÑ c.doProtoHandshakeËøõË°åÂçèËÆÆÊè°ÊâãÔºåÂÖ∑‰ΩìÂÆûÁé∞ÈÉΩÊòØRLPXÂÅöÁöÑ ‰πãÁöÑÁöÑÊúâÂÖ≥BOEÁöÑÈÄªËæëÊ≤°Â§™ÁúãÊòéÁôΩ ÊúÄÂêésrv.checkpointÊòØÂ∞ÜËøûÊé•ÂØπË±°connÂèëÈÄÅÁªôÈÄöÈÅìstage123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131// SetupConn runs the handshakes and attempts to add the connection// as a peer. It returns when the connection has been added as a peer// or the handshakes have failed.func (srv *Server) SetupConn(fd net.Conn, flags connFlag, dialDest *discover.Node) &#123; // Prevent leftover pending conns from entering the handshake. srv.lock.Lock() running := srv.running srv.lock.Unlock() c := &amp;conn&#123;fd: fd, transport: srv.newTransport(fd), flags: flags, cont: make(chan error)&#125; if !running &#123; c.close(errServerStopped) return &#125; srv.setupLock.Lock() defer srv.setupLock.Unlock() // Run the encryption handshake. var err error var ourRand, theirRand []byte if c.id, ourRand, theirRand, err = c.doEncHandshake(srv.PrivateKey, dialDest); err != nil &#123; log.Debug("Failed RLPx handshake", "addr", c.fd.RemoteAddr(), "conn", c.flags, "reason", err) c.close(err) return &#125; clog := log.New("id", c.id, "addr", c.fd.RemoteAddr(), "conn", c.flags) // For dialed connections, check that the remote public key matches. if dialDest != nil &amp;&amp; c.id != dialDest.ID &#123; c.close(DiscUnexpectedIdentity) clog.Error("Dialed identity mismatch", "want", c, dialDest.ID) return &#125; if err := srv.checkpoint(c, srv.posthandshake); err != nil &#123; clog.Trace("Rejected peer before protocol handshake", "err", err) c.close(err) return &#125; log.Debug("Do enc handshake OK.","id",c.id) ///////////////////////////////////////////////////////////////////////////////// // Run the protocol handshake c.our = *srv.ourHandshake c.our.RandNonce = ourRand if c.our.Sign, err = boe.BoeGetInstance().HW_Auth_Sign(theirRand); err!=nil&#123; clog.Debug("Do hardware sign error.","err",err) //todo close and return &#125; clog.Debug("Hardware has signed remote rand.","rand",theirRand,"sign",c.our.Sign) their, err := c.doProtoHandshake(&amp;c.our) if err != nil &#123; clog.Debug("Failed proto handshake", "err", err) c.close(err) return &#125; if their.ID != c.id &#123; clog.Error("Wrong devp2p handshake identity", "err", their.ID) c.close(DiscUnexpectedIdentity) return &#125; c.their = *their clog.Debug("Do protocol handshake OK.","id",c.id) clog.Trace("Do protocol handshake.","our",c.our,"their",c.their) ///////////////////////////////////////////////////////////////////////////////// isRemoteBoot := false hdtab := srv.getHdtab() for _, n := range srv.BootstrapNodes &#123; if c.id == n.ID &#123; clog.Info("Remote node is boot.","id",c.id) c.isboe = true isRemoteBoot = true &#125; &#125; if !c.isboe &#123; remoteCoinbase := strings.ToLower(c.their.CoinBase.String()) clog.Trace("Remote coinbase","address",remoteCoinbase) if len(hdtab) == 0 &#123; clog.Debug("Do not ready for connected.","id",c.id.TerminalString()) c.close(DiscHwSignError) return &#125; for _,hw := range hdtab &#123; if hw.Adr == remoteCoinbase &#123; clog.Debug("Input to boe paras","rand",c.our.RandNonce,"hid",hw.Hid,"cid",hw.Cid,"sign",c.their.Sign) c.isboe = boe.BoeGetInstance().HW_Auth_Verify(c.our.RandNonce,hw.Hid,hw.Cid,c.their.Sign) clog.Info("Boe verify the remote.","id",c.id.TerminalString(),"result",c.isboe) &#125; &#125; &#125; clog.Info("Verify the remote hardware.","id",c.id.TerminalString(),"result",c.isboe) if !srv.TestMode &amp;&amp; srv.localType == discover.SynNode &amp;&amp; c.isboe == false &#123; clog.Debug("SynNode peer SynNode, dorp peer.") c.close(DiscHwSignError) return &#125; if isRemoteBoot || srv.localType == discover.BootNode &#123; ourHdtable := &amp;hardwareTable&#123;Version:0x00,Hdtab:hdtab&#125; theirHdtable, err := c.doHardwareTable(ourHdtable) if err != nil &#123; clog.Debug("Failed hardware table handshake", "reason", err) c.close(err) return &#125; clog.Trace("Exchange hardware table.","our",ourHdtable, "their",theirHdtable) if isRemoteBoot&#123; srv.updateHdtab(theirHdtable.Hdtab,true) clog.Trace("Update hardware table from boot.","srv hdtab", srv.getHdtab() ) &#125; &#125; ///////////////////////////////////////////////////////////////////////////////// if err := srv.checkpoint(c, srv.addpeer); err != nil &#123; clog.Warn("Rejected peer", "err", err, "dialDest",dialDest) c.close(err) return &#125;&#125; ÂΩìÊé•Êî∂Âà∞ÁöÑËøûÊé•ÂèëÈÄÅÂà∞stageÈÄöÈÅìÂêéÔºåÈÇ£‰πàÈÄöÈÅìÁöÑÂ§ÑÁêÜÊòØÂú®srv.runËøõË°åÂ§ÑÁêÜÁöÑÔºå‰πüÂ∞±ÊòØprm.server.Start()ÊúÄÂêé‰∏ÄÊ≠•‰ª£Á†Åsrv.run„ÄÇÂÖ∂‰∏≠ÂàÜÊîØcase c := &lt;-srv.addpeer:‰∏≠ÁöÑgo srv.runPeer(p)ÊñπÊ≥ïÂºÄÂêØ‰∫ÜÂØπËøûÊé•ÁöÑÂøÉË∑≥Ê£ÄÊµãÔºåÂêåÊó∂ËøõË°å‰∫ÜËäÇÁÇπÂπøÊí≠„ÄÇ‰∏äËæπÂàÜÊûêÁöÑÈÉΩÊòØÊú¨ËäÇÁÇπ‰Ωú‰∏∫ÊúçÂä°ÁõëÂê¨ËÄÖË¢´Âä®Êé•Êî∂Âª∫Á´ãÁöÑËøûÊé•ÔºåËÄåËäÇÁÇπ‰∏ªÂä®ËøûÊé•ÂÖ∂‰ªñËäÇÁÇπÁöÑÂä®‰ΩúÊòØÂú®‰πüÊòØÂú®srv.run(dialer)‰∏≠ËøõË°åÁöÑÔºåÂÖ∂ÂèÇÊï∞dialerÂåÖÂê´ÊúâÂØπÊñπËäÇÁÇπËøûÊé•‰ø°ÊÅØÔºåÂåÖÊã¨bootËäÇÁÇπÂú∞ÂùÄ„ÄÇ È¶ñÂÖàÂàõÂª∫‰∫Ü‰∏â‰∏™‰ªªÂä°ÊñπÊ≥ïdelTask„ÄÅstartTasksÂíåscheduleTasksÔºåÂêåÊó∂ÂàõÂª∫‰∫Ü‰∏§‰∏™Êï∞ÁªÑÔºå‰∏Ä‰∏™ÊòØ‰øùÂ≠òÊ≠£Âú®ËøêË°åÁöÑtaskÔºå‰∏Ä‰∏™ÁºìÂ≠òÂ∞ÜË¢´ËøêË°åÁöÑtask„ÄÇÂà†Èô§ÁöÑÊó∂ÂÄôÂè™ËÉΩ‰ªéÊ≠£Âú®ËøêË°åÁöÑÊï∞ÁªÑ‰∏≠Âà†Èô§ÔºåËøêË°åÁöÑÊó∂ÂÄôÊúÄÂ§ßËøêË°å‰∏™Êï∞‰∏çËÉΩË∂ÖËøámaxActiveDialTasks=16‰∏™ÔºåÂÖ∂‰∏≠scheduleTasksÁî®Êù•ÂàõÂª∫ÂæÖËøêË°åÁöÑtaskÔºå‰∏ªÂä®ËøûÊé•ÁöÑËäÇÁÇπÂàÜbootËäÇÁÇπ„ÄÅÈùôÊÄÅËäÇÁÇπÂíåÂä®ÊÄÅËäÇÁÇπÔºåÂÖ∂‰∏≠ÈùôÊÄÅËäÇÁÇπÂ∞±ÊòØÊâãÂä®ÈÖçÁΩÆÁöÑÔºåÂä®ÊÄÅËäÇÁÇπÊòØÁ®ãÂ∫èKADÁÆóÊ≥ïËÆ°ÁÆóÂæóÂà∞ÁöÑ„ÄÇ Âú®startTasksÊñπÊ≥ï‰∏≠ÈÄöËøát.Do(srv)ËøõË°åËäÇÁÇπÁöÑËøûÊé•Êìç‰ΩúÔºåÊúÄÁªàËøòÊòØ‰ºöÊâßË°åsrv.SetupConnÊñπÊ≥ïÔºå‰πüÂ∞±ÊòØ‰∏äËæπÂàÜÊûêÁöÑÂª∫Á´ãËøûÊé•ÁöÑËøáÁ®ã„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166func (srv *Server) run(dialstate dialer) &#123; defer srv.loopWG.Done() var ( peers = make(map[discover.NodeID]*PeerBase) taskdone = make(chan task, maxActiveDialTasks) runningTasks []task queuedTasks []task // tasks that can't run yet ) // removes t from runningTasks delTask := func(t task) &#123; for i := range runningTasks &#123; if runningTasks[i] == t &#123; runningTasks = append(runningTasks[:i], runningTasks[i+1:]...) break &#125; &#125; &#125; // starts until max number of active tasks is satisfied startTasks := func(ts []task) (rest []task) &#123; i := 0 for ; len(runningTasks) &lt; maxActiveDialTasks &amp;&amp; i &lt; len(ts); i++ &#123; t := ts[i] go func() &#123; //log.Error("###### start task.","task",t) //time.Sleep(time.Second*time.Duration(rand.Intn(3))) t.Do(srv) //time.Sleep(time.Second*time.Duration(rand.Intn(3))) //log.Error("###### task done.") taskdone &lt;- t &#125;() runningTasks = append(runningTasks, t) &#125; return ts[i:] &#125; scheduleTasks := func() &#123; // Start from queue first. queuedTasks = append(queuedTasks[:0], startTasks(queuedTasks)...) // Query dialer for new tasks and start as many as possible now. if len(runningTasks) &lt; maxActiveDialTasks &#123; var nt []task if srv.localType == discover.BootNode &#123; nt = append(nt, &amp;waitExpireTask&#123;time.Second&#125;) &#125;else&#123; nt = dialstate.newTasks(len(runningTasks)+len(queuedTasks), peers, time.Now()) &#125; queuedTasks = append(queuedTasks, startTasks(nt)...) &#125; &#125;running: for &#123; scheduleTasks() srv.delHist.expire(time.Now()) log.Trace("###### Server running: expire node from history.","DelHist",srv.delHist.Len()) select &#123; case &lt;-srv.quit: // The server was stopped. Run the cleanup logic. break running case n := &lt;-srv.addstatic: // This channel is used by AddPeer to add to the // ephemeral static peer list. Add it to the dialer, // it will keep the node connected. log.Debug("Adding static node", "node", n) dialstate.addStatic(n) case n := &lt;-srv.removestatic: // This channel is used by RemovePeer to send a // disconnect request to a peer and begin the // stop keeping the node connected log.Debug("Removing static node", "node", n) dialstate.removeStatic(n) if p, ok := peers[n.ID]; ok &#123; p.Disconnect(DiscRequested) &#125; case op := &lt;-srv.peerOp: // This channel is used by Peers and PeerCount. op(peers) srv.peerOpDone &lt;- struct&#123;&#125;&#123;&#125; case t := &lt;-taskdone: // A task got done. Tell dialstate about it so it // can update its state and remove it from the active // tasks list. //log.Error("###### Dial task done", "task", t) dialstate.taskDone(t, time.Now()) delTask(t) case c := &lt;-srv.posthandshake: // A connection has passed the encryption handshake so // the remote identity is known (but hasn't been verified yet). // TODO: track in-progress inbound node IDs (pre-Peer) to avoid dialing them. select &#123; case c.cont &lt;- srv.encHandshakeChecks(peers, c): case &lt;-srv.quit: break running &#125; case c := &lt;-srv.addpeer: // At this point the connection is past the protocol handshake. // Its capabilities are known and the remote identity is verified. err := srv.protoHandshakeChecks(peers, c) if err == nil &#123; // The handshakes are done and it passed all checks. p := newPeerBase(c, srv.Protocols[0], srv.ntab) // If message events are enabled, pass the peerFeed // to the peer if srv.EnableMsgEvents &#123; p.events = srv.peerEvent &#125; p.beatStart = time.Now() srv.setPeerInitType(p, c.isboe) ////////////////////////////////////////////////////////// log.Debug("Server add peer base to run.", "id", c.id, "raddr", c.fd.RemoteAddr()) peers[c.id] = p go srv.runPeer(p) &#125; // The dialer logic relies on the assumption that // dial tasks complete after the peer has been added or // discarded. Unblock the task last. select &#123; case c.cont &lt;- err: case &lt;-srv.quit: break running &#125; case pd := &lt;-srv.delpeer: // A peer disconnected. nid := pd.ID() d := common.PrettyDuration(mclock.Now() - pd.created) pd.log.Info("Removing p2p peer", "duration", d) pd.log.Debug("Removing p2p peer", "duration", d, "req", pd.requested, "err", pd.err) delete(peers, nid) shortid := fmt.Sprintf("%x", nid[0:8]) if err := PeerMgrInst().unregister(shortid); err != nil &#123; log.Debug("Peer removal failed", "peer", shortid, "err", err) &#125; srv.ntab.RemoveNode(nid) expire := time.Second*time.Duration(10+rand.Intn(20)) srv.delHist.add(nid, time.Now().Add(expire)) log.Debug("Server running: add node to history.","expire",expire) &#125; &#125; log.Debug("P2P networking is spinning down") // Terminate discovery. If there is a running lookup it will terminate soon. if srv.ntab != nil &#123; srv.ntab.Close() &#125; // Disconnect all peers. for _, p := range peers &#123; p.Disconnect(DiscQuitting) &#125; // Wait for peers to shut down. Pending connections and tasks are // not handled here and will terminate soon-ish because srv.quit // is closed. for len(peers) &gt; 0 &#123; p := &lt;-srv.delpeer p.log.Trace("&lt;-delpeer (spindown)", "remainingTasks", len(runningTasks)) delete(peers, p.ID()) &#125;&#125; ËøôÂùó‰ª£Á†ÅÊå∫Â§çÊùÇÁöÑÔºåÂêÑÁßçgo routineÂíåchanÁöÑ‰ΩøÁî®„ÄÇüòÇüòÇüòÇüòÇüòÇüòÇüòÇüòÇ]]></content>
      <categories>
        <category>HPBÊ∫êÁ†ÅËß£ËØª</category>
      </categories>
      <tags>
        <tag>HPB</tag>
        <tag>Âå∫ÂùóÈìæ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GO-HPBÊ∫êÁ†ÅËß£ËØª--‰∫§ÊòìÂÖ•Ê±†Ôºà‰∫åÔºâ]]></title>
    <url>%2F2019%2F07%2F21%2FGO-HPB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E4%BA%A4%E6%98%93%E5%85%A5%E6%B1%A0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[‰∏ä‰∏ÄËäÇÁúãÂà∞‰∫§ÊòìÈÄöËøápool.promoteTx(addr, hash, tx)ÊñπÊ≥ïËøõË°å‰∫Ü‰º†ÈÄíÔºåÂú®ËØ•ÊñπÊ≥ïÁöÑÊúÄÂêé‰∏ÄÊ≠•ÈÄöËøápool.txFeed.Send(bc.TxPreEvent{tx})ÔºåÂ∞Ü‰∫§ÊòìÂ∞ÅË£ÖÊàêbc.TxPreEventÂèëÈÄÅ‰∫ÜÂá∫Âéª„ÄÇËÄåËøô‰∏™FeedÂÆûÁé∞‰∫ÜËÆ¢ÈòÖÂèëÂ∏ÉÊ®°ÂºèÔºåSendÊñπÊ≥ïÊòØÂèëÂ∏ÉÊ∂àÊÅØÔºåSubscribeTxPreEventÊòØËÆ¢ÈòÖÊ∂àÊÅØÔºåËÆ¢ÂçïÁöÑÊó∂ÂÄôÂè™ÈúÄË¶ÅÊääËÆ¢ÂçïËÄÖÁöÑchanÂèëËøõÊù•Â∞±ÂèØ‰ª•‰∫Ü„ÄÇ ÔºàFeedÈÄöËøáÂèçÂ∞ÑÂåÖreflect‰∏≠ÁöÑselectcase„ÄÅtrySendÂíåtryReceiveÊñπÊ≥ïËøõË°åÁöÑÔºåÊìç‰ΩúÂåÖË£ÖÂú®FeedÊñá‰ª∂‰∏≠ÔºågolangÁöÑÊ∫êÁ†ÅÂåÖ‰∏≠Êúâall_test.goÊµãËØïÊñá‰ª∂ÂèØ‰ª•ËØ¶ÁªÜÁúã‰∏ãÔºâËÆ¢ÈòÖËøô‰∏™Ê∂àË¥πÁöÑ‰∏ÄÂÖ±Êúâ‰∏â‰∏™Âú∞ÊñπÔºåÂàÜ‰∏≠Âú®api_backend.go„ÄÅsynctrl.go„ÄÅworker.go‰∏≠„ÄÇËøôÈáå‰∏ªË¶ÅÁúã‰∏Ä‰∏ãÂπøÊí≠ÂíåevnÊâßË°å„ÄÇ api_backend.go‰∏≠Âè™ÊòØËÆ¢ÂçïÂπ∂Ê≤°Â§ÑÁêÜ synctrl.go‰∏≠ËøõË°åÊ∂àË¥πÁöÑÂπøÊí≠ worker.go‰∏≠ËøõË°å‰∫ÜevnÊâßË°å 123func (pool *TxPool) SubscribeTxPreEvent(ch chan&lt;-bc.TxPreEvent) sub.Subscription &#123; return pool.scope.Track(pool.txFeed.Subscribe(ch))&#125; Âú®synctrl.goÁöÑË∞ÉÁî®È°∫Â∫èÊòØ‚Äì&gt;main‚Äì&gt;ghpb‚Äì&gt;startNode‚Äì&gt;‚Äì&gt;utils.StartNode(stack)‚Äì&gt;hpbnode.Start()‚Äì&gt;‚Äì&gt;hpbnode.Hpbsyncctr.Start() Âú®StartÊñπÊ≥ï‰∏≠ÂàùÂßãÂåñthis.txChÔºåÂπ∂ËøõË°åÊ∂àÊÅØËÆ¢Âçï Ê∂àÊÅØÁöÑÊ∂àË¥πÊòØÂú®txRoutingLoopÂçèÁ®ã‰∏≠ Âú®routTxÊñπÊ≥ï‰∏≠ÔºåÊâæÂá∫‰∏çÁü•ÈÅìËØ•‰∫§ÊòìÁöÑpeerÔºåÁÑ∂ÂêéÈÄê‰∏™ÂèëÂá∫Âéª‰∫Ü123456789101112131415161718192021222324func (this *SynCtrl) Start() &#123; // broadcast transactions this.txCh = make(chan bc.TxPreEvent, txChanSize) this.txSub = this.txpool.SubscribeTxPreEvent(this.txCh) go this.txRoutingLoop() // broadcast mined blocks this.minedBlockSub = this.newBlockMux.Subscribe(bc.NewMinedBlockEvent&#123;&#125;) go this.minedRoutingLoop() // start sync handlers go this.sync() go this.txsyncLoop()&#125;func (this *SynCtrl) txRoutingLoop() &#123; for &#123; select &#123; case event := &lt;-this.txCh: routTx(event.Tx.Hash(), event.Tx) &#125; &#125;&#125; Âú®worker.goÁöÑË∞ÉÁî®È°∫Â∫èÊòØ‚Äì&gt;main‚Äì&gt;ghpb‚Äì&gt;startNode‚Äì&gt;‚Äì&gt;hpbnode.WorkerInit‚Äì&gt;worker.New‚Äì&gt;newWorkerÂú®newWorker‰∏≠ÂàùÂßãÂåñworker.txChÔºåÂπ∂ËÆ¢ÈòÖÊ∂àÊÅØÔºåÊ∂àÊÅØÁöÑÂ§ÑÁêÜÊòØÂú®ÂçèÁ®ãworker.eventListener()‰∏≠ËøõË°åÁöÑ„ÄÇÂú®Á≥ªÁªüÊ≤°ÊúâÊåñÁüøÁöÑÁä∂ÊÄÅ‰∏ãÔºåÊääÊ∂àÊÅØÂèëÈÄÅÂà∞commitTransactionsËøõË°åÂ§ÑÁêÜ„ÄÇcommitTransactions‰ºöÊää‰∫§ÊòìÊèê‰∫§Âà∞evmËøõË°åÊâßË°åÔºåËøô‰∏™ÂçïÁã¨Ëß£Êûê‰∏ãÂêß„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768func newWorker(config *config.ChainConfig, engine consensus.Engine, coinbase common.Address, /*eth Backend,*/ mux *sub.TypeMux) *worker &#123; worker := &amp;worker&#123; config: config, engine: engine, mux: mux, /*txCh: make(chan bc.TxPreEvent, txChanSize),*/ chainHeadCh: make(chan bc.ChainHeadEvent, chainHeadChanSize), chainSideCh: make(chan bc.ChainSideEvent, chainSideChanSize), chainDb: nil,//hpbdb.ChainDbInstance(), recv: make(chan *Result, resultQueueSize), chain: bc.InstanceBlockChain(), proc: bc.InstanceBlockChain().Validator(), possibleUncles: make(map[common.Hash]*types.Block), coinbase: coinbase, producers: make(map[Producer]struct&#123;&#125;), unconfirmed: newUnconfirmedBlocks(bc.InstanceBlockChain(), miningLogAtDepth), &#125; worker.pool = txpool.GetTxPool() worker.txCh = make(chan bc.TxPreEvent, txChanSize) worker.txSub = worker.pool.SubscribeTxPreEvent(worker.txCh) worker.chainHeadSub = bc.InstanceBlockChain().SubscribeChainHeadEvent(worker.chainHeadCh) worker.chainSideSub = bc.InstanceBlockChain().SubscribeChainSideEvent(worker.chainSideCh) //ÂØπ‰ª•‰∏ä‰∫ã‰ª∂ÁöÑÁõëÂê¨ go worker.eventListener() go worker.handlerSelfMinedBlock() return worker&#125;func (self *worker) eventListener() &#123; defer self.txSub.Unsubscribe() defer self.chainHeadSub.Unsubscribe() defer self.chainSideSub.Unsubscribe() for &#123; // A real event arrived, process interesting content select &#123; // Handle ChainHeadEvent case &lt;-self.chainHeadCh: self.startNewMinerRound() // Handle ChainSideEvent case ev := &lt;-self.chainSideCh: self.uncleMu.Lock() self.possibleUncles[ev.Block.Hash()] = ev.Block self.uncleMu.Unlock() // Handle TxPreEvent case ev := &lt;-self.txCh: // Apply transaction to the pending state if we're not mining if atomic.LoadInt32(&amp;self.mining) == 0 &amp;&amp; self.current != nil &#123; self.currentMu.Lock() acc, _ := types.Sender(self.current.signer, ev.Tx) txs := map[common.Address]types.Transactions&#123;acc: &#123;ev.Tx&#125;&#125; txset := types.NewTransactionsByPriceAndNonce(self.current.signer, txs) self.current.commitTransactions(self.mux, txset, self.coinbase) self.currentMu.Unlock() &#125; case &lt;-self.chainHeadSub.Err(): return case &lt;-self.chainSideSub.Err(): return &#125; &#125;&#125;]]></content>
      <categories>
        <category>HPBÊ∫êÁ†ÅËß£ËØª</category>
      </categories>
      <tags>
        <tag>HPB</tag>
        <tag>Âå∫ÂùóÈìæ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GO-HPBÊ∫êÁ†ÅËß£ËØª--‰∫§ÊòìÂÖ•Ê±†Ôºà‰∏ÄÔºâ]]></title>
    <url>%2F2019%2F07%2F21%2FGO-HPB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E4%BA%A4%E6%98%93%E5%85%A5%E6%B1%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Âú®Êú¨Âú∞ÂêØÂä®ËäÇÁÇπÂêéÔºåÈÄöËøáÊéßÂà∂Âè∞ËæìÂÖ•ÂëΩ‰ª§hpb.sendTransaction({from:&quot;db3cf5c98af974d3cccdc8662f1ab3c27c6e47ee&quot;,to:&quot;742c8a59152a397ad09f7fb280c4fc378598a4ba&quot;,value:web3.toWei(10000,&quot;hpb&quot;)})Êù•ÂÆåÊàêËΩ¨Ë¥¶‰∫§Êòì„ÄÇ‰∫§ÊòìÂÜÖÂÆπÊúÄÂàùÂßã‰ºöËøõÂÖ•Âà∞SendTransaction„ÄÇ ÊâìÂç∞‰∫Ü‰∏Ä‰∏ã‰º†ËøõÊù•ÁöÑÂèÇÊï∞args{From:[219 60 245 201 138 249 116 211 204 205 200 102 47 26 179 194 124 110 71 238] To:[116 44 138 89 21 42 57 122 208 159 127 178 128 196 252 55 133 152 164 186] Gas: GasPrice: Value:0x21e19e0c9bab2400000 Data:0x Nonce:} È¶ñÂÖàÊ£ÄÊü•‰∏Ä‰∏ãfromÂú∞ÂùÄÊòØ‰∏çÊòØÂ≠òÂú®Èí±ÂåÖ‰∏≠ÔºåÂ¶ÇÊûú‰∏çÂ≠òÂú®Â∞±ËøîÂõûÈîôËØØ ÈîÅÂÆö‰∫§ÊòìÁöÑnonceÔºåÂõ†‰∏∫nonceÊòØÂîØ‰∏ÄÁöÑÔºåÈò≤Ê≠¢‰∫§ÊòìÁöÑÈáçÊí≠ÊîªÂáª ÂØπ‰∫§ÊòìÈúÄË¶ÅÁöÑÂÖ∂‰ªñÂèÇÊï∞ËøõË°åËÆæÁΩÆÔºåGasÈªòËÆ§ÂÄº‰∏∫90000ÔºåGasPriceÂíåNonceÁªèÁî±ËÆ°ÁÆóËé∑ÂæóÔºåËøô‰∏™ÂêéÁª≠ÂÜçÂàÜÊûê ÂàõÂª∫‰∏Ä‰∏™‰∫§ÊòìÂØπË±°ÔºåÂ∞Ü‰ª•‰∏äÂèÇÊï∞ËøõË°åËµãÂÄº ‰ΩøÁî®fromÁöÑÂ∏êÊà∑Èí±ÂåÖÂØπ‰∫§ÊòìËøõË°åÁ≠æÂêçÔºåÊù•ËØÅÊòéËøôÁ≠æ‰∫§ÊòìÁ°ÆÂÆûÊòØfromÂèëÂá∫ÁöÑ„ÄÇÁ≠æÂêçËøáÁ®ãÔºö(1). È¶ñÂÖà‰ΩøÁî®fromÁöÑÁßÅÈí•ÂØπnonce„ÄÅprice„ÄÅgaslimit„ÄÅrecipient„ÄÅamount„ÄÅpayloadËøõË°åsecp256k1Á≠æÂêç(2). ÁÑ∂ÂêéÁ≠æÂêçÁªìÊûúÂàÜËß£ÊàêR„ÄÅS„ÄÅVÔºåÂπ∂ËµãÁªô‰∫§ÊòìÂØπË±°ÔºåÊ≥®ÊÑèËøô‰∏™Êó∂ÂÄô‰∫§ÊòìÂØπË±°‰∏≠Âπ∂Ê≤°ÊúâfromÂú∞ÂùÄ ÊúÄÂêéÊèê‰∫§‰∫§Êòì 123456789101112131415161718192021222324252627282930313233343536// SendTransaction creates a transaction for the given argument, sign it and submit it to the// transaction pool.func (s *PublicTransactionPoolAPI) SendTransaction(ctx context.Context, args SendTxArgs) (common.Hash, error) &#123; // Look up the wallet containing the requested signer account := accounts.Account&#123;Address: args.From&#125; wallet, err := s.b.AccountManager().Find(account) if err != nil &#123; return common.Hash&#123;&#125;, err &#125; if args.Nonce == nil &#123; // Hold the addresse's mutex around signing to prevent concurrent assignment of // the same nonce to multiple accounts. s.nonceLock.LockAddr(args.From) defer s.nonceLock.UnlockAddr(args.From) &#125; // Set some sanity defaults and terminate on failure if err := args.setDefaults(ctx, s.b); err != nil &#123; return common.Hash&#123;&#125;, err &#125; // Assemble the transaction and sign with the wallet tx := args.toTransaction() var chainID *big.Int if config := s.b.ChainConfig(); true &#123; chainID = config.ChainId &#125; signed, err := wallet.SignTx(account, tx, chainID) if err != nil &#123; return common.Hash&#123;&#125;, err &#125; return submitTransaction(ctx, s.b, signed)&#125; submitTransactionÊñπÊ≥ïÊää‰∫§ÊòìÊèê‰∫§Âà∞‰∫§ÊòìÊ±†txpool È¶ñÂÖàËÆ°ÁÆó‰∫§ÊòìÁöÑhashÔºåËøô‰∏™‰∫§ÊòìÂú®ËæìÂÖ•‰∫§ÊòìÂëΩ‰ª§ÂêéÊòæÁ§∫ÁöÑÈÇ£‰∏™hashÂÄº Âà§Êñ≠‰∫§ÊòìÊ±†‰∏≠ÊòØÂê¶ÂåÖÂê´ËØ•‰∫§ÊòìÔºåÂåÖÂê´ÁöÑËØùÂ∞±Áõ¥Êé•ÂõûÈÄÄÂ§±Ë¥• È™åËØÅ‰∫§Êòì ÈîÅÂÆö‰∫§ÊòìÔºå‰πüÂ∞±ÊòØÊää‰∫§Êòì‰øùÂ≠òÂà∞‰∫§ÊòìÊ±†ÁöÑËøáÁ®ã123456789101112131415161718// AddTx attempts to queue a transactions if valid.func (pool *TxPool) AddTx(tx *types.Transaction) error &#123; pool.mu.Lock() defer pool.mu.Unlock() hash := tx.Hash() if pool.all[hash] != nil &#123; log.Trace("Discarding already known transaction", "hash", hash) return fmt.Errorf("known transaction: %x", hash) &#125; // If the transaction fails basic validation, discard it if err := pool.validateTx(tx); err != nil &#123; log.Trace("Discarding invalid transaction", "hash", hash, "err", err) return err &#125; return pool.addTxLocked(tx)&#125; validateTxÂØπ‰∫§ÊòìËøõË°åÈ™åËØÅ ‰∫§ÊòìÁöÑÂ§ßÂ∞èÊòØÂê¶Ë∂ÖËøá32kÔºåÂÖ∂‰∏≠ÁöÑtx.Size‰∏ªË¶ÅËÆ°ÁÆóÁöÑÊòØ‰∫§ÊòìÁöÑdataÈÉ®ÂàÜÁöÑÊï∞ÊçÆÂ§ßÂ∞è ‰∫§ÊòìÈáëÈ¢ù‰∏çËÉΩÂ∞è‰∫é0 ÂΩìÂâç‰∫§ÊòìÁöÑgasLimitÊòØÂê¶Â§ß‰∫éÂΩìÂâçÂå∫ÂùóÁöÑÊúÄÂ§ßgasÂÄºÔºåÊØè‰∏™Âå∫ÂùóÂùóÈÉΩÊúâ‰∏Ä‰∏™ÊÄªÁöÑgasÈôêÂà∂Ôºå‰πüÂ∞±ÊòØ‰∏Ä‰∏™Âå∫Âùó‰∏≠ÁöÑÊâÄÊúâ‰∫§ÊòìÁöÑgasÊÄªÂíå‰∏çËÉΩË∂ÖËøáÂå∫ÂùóÁöÑgasÈôêÂà∂ È™åËØÅÁ≠æÂêçÊòØÂê¶ÊúâÊïàÔºåÂπ∂ËøòÂéüÂá∫Âú∞ÂùÄfromÔºàËøôÂùóÊ≤°ÁªÜÁúãÔºå‰πãÂêéÂÜçÁúã‰∏ãÔºâ ‰∫§ÊòìÁªôÂá∫ÁöÑgas‰ª∑Ê†ºÂøÖÈ°ªÂ§ß‰∫étxpoolÁöÑÊúÄ‰Ωé‰ª∑Ê†ºÔºåË¶Å‰∏çÁÑ∂ÊåñÂ∑•Êî∂Áõä‰ºöÂ∞ë ÂΩìÂâç‰∫§ÊòìÁöÑnonceÂøÖÈ°ªË¶ÅÂ§ß‰∫é‰∏ä‰∏ÄÊ¨°ÁöÑ‰∫§Êòìnonce„ÄÇÂ∏êÊà∑‰ø°ÊÅØÁõ¥Êé•‰øùÂ≠òÂú®stateDB‰∏≠ÔºåÂèØ‰ª•‰ªé‰∏≠Ëé∑Âèñ ‰∫§ÊòìËä±Ë¥πgasprice*gasLimitÂøÖÈ°ªÂ§ß‰∫éÂ∏êÊà∑‰ΩôÈ¢ù Â¶ÇÊûú‰∫§ÊòìÊòØÂàõÂª∫ÂêàÁ∫¶ÊàñËÄÖË∞ÉÁî®ÂêàÁ∫¶ÔºåÈúÄË¶ÅËÆ°ÁÆó‰∏Ä‰∏ãÈúÄË¶ÅÂ§öÂ∞ëgasÔºåÂ¶ÇÊûú‰∫§ÊòìÊîØ‰ªòÁöÑÊúÄÂ§ßgas‰∏çÂ§üÂ§ö‰πüÊòØÊãíÁªùÁöÑÔºàËøôÂùóÊ≤°ÁªÜÁúãÔºå‰πãÂêéÂÜçÁúã‰∏ãÔºâ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// validateTx checks whether a transaction is valid according to the consensus// rules and adheres to some heuristic limits of the local node (price and size).func (pool *TxPool) validateTx(tx *types.Transaction) error &#123; // Heuristic limit, reject transactions over 32KB to prevent DOS attacks if tx.Size() &gt; maxTransactionSize &#123; log.Trace("ErrOversizedData maxTransactionSize", "ErrOversizedData",ErrOversizedData) return ErrOversizedData &#125; // Transactions can't be negative. This may never happen using RLP decoded // transactions but may occur if you create a transaction using the RPC. if tx.Value().Sign() &lt; 0 &#123; log.Trace("ErrNegativeValue", "ErrNegativeValue",ErrNegativeValue) return ErrNegativeValue &#125; // Ensure the transaction doesn't exceed the current block limit gas. if pool.currentMaxGas.Cmp(tx.Gas()) &lt; 0 &#123; log.Trace("ErrGasLimit", "ErrGasLimit",ErrGasLimit) return ErrGasLimit &#125; // Call BOE recover sender. from, err := types.Sender(pool.signer, tx) if err != nil &#123; log.Trace("ErrInvalidSender", "ErrInvalidSender",ErrInvalidSender) return ErrInvalidSender &#125; // Check gasPrice. if pool.gasPrice.Cmp(tx.GasPrice()) &gt; 0 &#123; log.Trace("ErrUnderpriced", "ErrUnderpriced",ErrUnderpriced) return ErrUnderpriced &#125; // Ensure the transaction adheres to nonce ordering if pool.currentState.GetNonce(from) &gt; tx.Nonce() &#123; log.Trace("ErrNonceTooLow", "tx.Nonce()",tx.Nonce()) return ErrNonceTooLow &#125; // Transactor should have enough funds to cover the costs // cost == V + GP * GL if pool.currentState.GetBalance(from).Cmp(tx.Cost()) &lt; 0 &#123; log.Trace("ErrInsufficientFunds", "ErrInsufficientFunds",ErrInsufficientFunds) return ErrInsufficientFunds &#125; intrGas := types.IntrinsicGas(tx.Data(), tx.To() == nil) if tx.Gas().Cmp(intrGas) &lt; 0 &#123; log.Trace("ErrIntrinsicGas", "ErrIntrinsicGas",ErrIntrinsicGas) return ErrIntrinsicGas &#125; return nil&#125; 1234567891011121314// addTx enqueues a single transaction into the pool if it is valid.func (pool *TxPool) addTxLocked(tx *types.Transaction) error &#123; // Try to inject the transaction and update any state replace, err := pool.add(tx) if err != nil &#123; return err &#125; // If we added a new transaction, run promotion checks and return if !replace &#123; from, _ := types.Sender(pool.signer, tx) // already validated pool.promoteExecutables([]common.Address&#123;from&#125;) &#125; return nil&#125; pool.addÊñπÊ≥ï‰∏≠ È¶ñÂÖàËÆ°ÁÆó‰∫§ÊòìÁöÑhashÔºåÂπ∂Ëé∑ÂèñfromÂú∞ÂùÄ Âà§Êñ≠‰∫§ÊòìÊ±†ÊòØÂê¶Êª°‰∫ÜÔºåÂ¶ÇÊûúÊª°‰∫ÜÂ∞±ËøîÂõûÂ§±Ë¥•„ÄÇËøôÈáåÈúÄË¶ÅÊ≥®ÊÑè‰∏Ä‰∏ã‰∫§ÊòìÊ±†Áª¥Êä§ÁùÄ‰∏§‰∏™ÈõÜÂêà‰∏Ä‰∏™ÊòØpendingÔºå‰∏Ä‰∏™ÊòØqueueÔºåpendingÂ≠òÊîæÁöÑÊòØÂèØ‰ª•Â§ÑÁêÜÁöÑ‰∫§ÊòìÔºåqueueÂ≠òÊîæÁöÑÊòØ‰∏çÂèØ‰ª•Â§ÑÁêÜÁöÑ‰∫§Êòì„ÄÇ Êää‰∫§ÊòìÊ±†‰∏≠pendingÊâÄÊúâfromÂú∞ÂùÄÁöÑ‰∫§ÊòìÈÉΩÂèñÂá∫Êù•ËµãÂà∞listÔºåÁúãÁúãÊòØ‰∏çÊòØÂåÖÂê´Áõ∏ÂêåÁöÑnonceÁöÑ‰∫§Êòì„ÄÇÔºà‰∏äËæπÂú®ÂàõÂª∫‰∫§ÊòìÁöÑÊó∂ÂÄôÂà§Êñ≠‰∫ÜnonceÂ§ß‰∫éÂΩìÂâçÁöÑÔºå‰ªÄ‰πàÊÉÖÂÜµ‰∏ã‰ºöÈáçÂ§çÂë¢ÔºüÔºâÂ¶ÇÊûúÂåÖÂê´ÁöÑËØùÂ∞±ÂæÄlistÈáåÊèíÂÖ•Ôºå‰ΩÜÊòØÊèíÂÖ•ÁöÑÊó∂ÂÄôË¶ÅÂà§Êñ≠‰∏Ä‰∏ãËøôÁ¨î‰∫§ÊòìÂÄº‰∏çÂÄºÊõøÊç¢‰∏ä‰∏ÄÁ¨îÁõ∏ÂêånonceÁöÑ‰∫§Êòì„ÄÇ‰∫§ÊòìÊ±†Êúâ‰∏™ÂèÇÊï∞priceBumpÔºåË°®Á§∫‰∏äÊµÆ‰ª∑Ê†ºÔºåÊØîÂ¶ÇÊòØ20ÔºåÂΩìÊóß‰∫§ÊòìÁöÑold_gasprice*(100+20)/100=1.2ÂÄçÁöÑold_gaspreiceÔºåÂ¶ÇÊûúÂΩìÂâç‰∫§ÊòìÁöÑ‰ª∑Ê†ºÂ§ß‰∫é1.2ÂÄçÁöÑold_gaspreiceÔºåÂàôËøõË°åÊõøÊç¢„ÄÇÂêåÊó∂list‰πü‰ºöÊõ¥Êñ∞‰∏Ä‰∏ãÊúÄÂ§ß‰∫§ÊòìÈ¢ùÂíåÊúÄÂ§ßgasËøôÊó∂txpoolÊâç‰ºöÊääÂΩìÂâç‰∫§ÊòìÁºìÂ≠òËµ∑Êù• Â¶ÇÊûúlist‰πüÂ∞±ÊòØpending‰∏≠Ê≤°ÊúâÈáçÂ§çÁöÑ‰∫§ÊòìÔºåÈÇ£‰πàÂØπ‰∫équeue‰πüÂÅöÂêåÊ†∑ÁöÑÊõøÊç¢Êìç‰Ωú„ÄÇÊ≥®ÊÑèÂ¶ÇÊûúqueue‰∏≠‰∏çÂ≠òÂú®ËØ•‰∫§ÊòìÊòØ‰ºöÊèíÂÖ•ÁöÑÔºåpendingÊòØ‰∏ç‰ºöÁöÑ„ÄÇÔºàtxpool.queueÊòØ‰∏™mapÔºåkeyÊòØfromÂú∞ÂùÄÔºåvalueÊòØ‰∏™listÔºå‰øùÂ≠òÁùÄÊâÄÊúâfromÂú∞ÂùÄÁöÑ‰∫§Êòì‰ø°ÊÅØÔºå‰πüÂ∞±ÊòØ‰∏äËæπÊèêÂà∞ÁöÑlistÔºâ 12345678910111213141516171819202122232425262728293031323334353637383940414243func (pool *TxPool) add(tx *types.Transaction) (bool, error) &#123; // If the transaction is already known, discard it hash := tx.Hash() from, _ := types.Sender(pool.signer, tx) // already validated // If the transaction pool is full, reject if uint64(len(pool.all)) &gt;= pool.config.GlobalSlots+pool.config.GlobalQueue &#123; log.Warn("TxPool is full, reject tx", "current size", len(pool.all), "max size", pool.config.GlobalSlots+pool.config.GlobalQueue, "hash", hash, "from", from, "to", tx.To()) return false, ErrTxPoolFull &#125; // If the transaction is replacing an already pending one, do directly if list := pool.pending[from]; list != nil &amp;&amp; list.Overlaps(tx) &#123; // Nonce already pending, check if required price bump is met inserted, old := list.Add(tx, pool.config.PriceBump) if !inserted &#123; return false, ErrReplaceUnderpriced &#125; // New transaction is better, replace old one if old != nil &#123; delete(pool.all, old.Hash()) &#125; pool.all[tx.Hash()] = tx pool.tmpqueue[tx.Hash()] = tx log.Trace("Pooled new executable transaction", "hash", hash, "from", from, "to", tx.To()) // We've directly injected a replacement transaction, notify subsystems //TODO why inject event here //event.FireEvent(&amp;event.Event&#123;Trigger: pool.txPreTrigger, Payload: event.TxPreEvent&#123;tx&#125;, Topic: event.TxPreTopic&#125;) return old != nil, nil &#125; // New transaction isn't replacing a pending one, push into queue replace, err := pool.enqueueTx(hash, tx) if err != nil &#123; return false, err &#125; log.Trace("Pooled new future transaction", "hash", hash, "from", from, "to", tx.To()) return replace, nil&#125; Â¶ÇÊûú‰∫§ÊòìÊ±†‰∏≠ÁöÑqueueÊèíÂÖ•ÊàêÂäüÁöÑËØùÔºåqueueÊï∞ÊçÆÂèëÁîüÂèòÂåñÔºåÊé•‰∏ãÊù•promoteExecutablesÊñπÊ≥ïÂ∞±ÊòØË¶ÅÊääqueue‰∏≠Êüê‰∫õ‰∫§ÊòìÁßªÂà∞pending‰∏≠Ôºå‰ªé‰∏çÂèØ‰ª•Â§ÑÁêÜÁöÑÁä∂ÊÄÅÂèòÊàêÂèØÂ§ÑÁêÜÁöÑÁä∂ÊÄÅ Âà†Èô§ÊâÄÊúânonceÂ§™‰ΩéÁöÑ‰∫§Êòì Âà†Èô§Â∏êÊà∑‰ΩôÈ¢ùÂ§™‰ΩéÊàñgasË∂ÖËøá‰∫§ÊòìÊ±†ÈôêÂà∂ÁöÑ‰∫§Êòì Â∞Üqueue‰∫§ÊòìÊ∑ªÂä†Âà∞pending‰∏≠ÔºåÂêåÊó∂‰ºöÊää‰∫§ÊòìÂèëÈÄÅÂà∞chanÈÄöÈÅìÔºåchanÊé•Êî∂‰πãÂêéÂπøÊí≠Âà∞ÁΩëÁªú‰∏≠ÁöÑÂÖ∂‰ªñpeerËäÇÁÇπ Âà†Èô§Ë∂ÖËøáqueueÂÆπÈáèÈôêÂà∂ÁöÑ‰∫§Êòì ÊúÄÂêékeepFitÂ§ÑÁêÜË∂ÖËøápendingÂÆπÈáèÈôêÂà∂ÁöÑ‰∫§Êòì123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263func (pool *TxPool) promoteExecutables(accounts []common.Address) &#123; // Gather all the accounts potentially needing updates if accounts == nil &#123; accounts = make([]common.Address, 0, len(pool.queue)) for addr := range pool.queue &#123; accounts = append(accounts, addr) &#125; &#125; // Iterate over all accounts and promote any executable transactions for _, addr := range accounts &#123; list := pool.queue[addr] if list == nil &#123; continue // Just in case someone calls with a non existing account &#125; // Drop all transactions that are deemed too old (low nonce) for _, tx := range list.Forward(pool.currentState.GetNonce(addr)) &#123; hash := tx.Hash() log.Trace("Removed old queued transaction", "hash", hash) delete(pool.all, hash) &#125; // Drop all transactions that are too costly (low balance or out of gas) drops, _ := list.Filter(pool.currentState.GetBalance(addr), pool.currentMaxGas) for _, tx := range drops &#123; hash := tx.Hash() log.Trace("Removed unpayable queued transaction", "hash", hash) delete(pool.all, hash) &#125; // Gather all executable transactions and promote them for _, tx := range list.Ready(pool.pendingState.GetNonce(addr)) &#123; hash := tx.Hash() log.Trace("Promoting queued transaction", "hash", hash,"pool.pendingState.GetNonce(addr)",pool.pendingState.GetNonce(addr)) pool.promoteTx(addr, hash, tx) // Delete a single queue transaction if list != nil &#123; list.Remove(tx) &#125; &#125; // Drop all transactions over the allowed limit for _, tx := range list.Cap(int(pool.config.AccountQueue)) &#123; hash := tx.Hash() delete(pool.all, hash) log.Trace("Removed cap-exceeding queued transaction", "hash", hash) &#125; // Delete the entire queue entry if it became empty. if list.Empty() &#123; log.Trace("promoteExecutables list.Empty()") delete(pool.queue, addr) &#125; &#125; pool.keepFit()&#125;]]></content>
      <categories>
        <category>HPBÊ∫êÁ†ÅËß£ËØª</category>
      </categories>
      <tags>
        <tag>HPB</tag>
        <tag>Âå∫ÂùóÈìæ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GO-HPBÊ∫êÁ†ÅËß£ËØª--ÊäïÁ•®Êú∫Âà∂]]></title>
    <url>%2F2019%2F07%2F21%2FGO-HPB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%8A%95%E7%A5%A8%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Âú®ÊåñÁüøÊµÅÁ®ãÁöÑÊúÄËøë‰∏ÄËäÇ‰∏≠ÔºåÊèêÂà∞‰∫Üvoting.GetHpbNodeSnapÁöÑÊäïÁ•®Êú∫Âà∂„ÄÇÊäïÁ•®ÁöÑÁõÆÁöÑÂ∞±ÊòØÊù•ËÆ°ÁÆóÂá∫Êú¨ËäÇÁÇπÊòØÂê¶ËÉΩÂ§üÁ≠æÂêçÂå∫ÂùóÔºåÊâÄ‰ª•ÊØèÊ¨°Âú®ÁªÑË£ÖÂå∫ÂùóÁöÑÊó∂ÂÄôÈÉΩ‰ºöËé∑Âèñ‰∏ä‰∏ÄÊ¨°ÁöÑÊäïÁ•®ÁªìÊûúÔºåÂ¶ÇÊûúÂá∫Áé∞ÂºÇÂ∏∏ÊàñËÄÖÊäïÁ•®Âë®ÊúüÂà∞‰∫ÜÔºåÂàôÈáçÊñ∞ËÆ°ÁÆóÊäïÁ•®ÁªìÊûú„ÄÇÊäïÁ•®ÁªìÊûúÊòØÈÄöËøáÁªìÊûÑ‰ΩìËøõË°å‰øùÂ≠òÁöÑ„ÄÇCandAddress ËäÇÁÇπÂú∞ÂùÄ(ÂΩìÂâçÁöÑÊéàÊùÉÁî®Êà∑)VoteNumbers Ëé∑ÂæóÁ•®Êï∞VoteIndexs Ëé∑ËÉúËÄÖÁöÑÊåáÊ†áÊÄªÂíåVotePercent Âç†ÊØî 12345678910111213141516171819type Tally struct &#123; CandAddress common.Address `json:"candAddress"` // ÈÄöËøáÊäïÁ•®ÁöÑ‰∏™Êï∞ VoteNumbers *big.Int `json:"voteNumbers"` // ÈÄöËøáÊäïÁ•®ÁöÑ‰∏™Êï∞ VoteIndexs *big.Int `json:"voteIndexs"` // ÈÄöËøáÊäïÁ•®ÁöÑ‰∏™Êï∞ VotePercent *big.Int `json:"votePercent"` // ÈÄöËøáÊäïÁ•®ÁöÑ‰∏™Êï∞&#125;&lt;!-- more --&gt;type HpbNodeSnap struct &#123; config *config.PrometheusConfig sigcache *lru.ARCCache //Number uint64 `json:"number"` // ÁîüÊàêÂø´ÁÖßÁöÑÊó∂Èó¥ÁÇπ CheckPointNum uint64 `json:"checkPointNum"` // ÊúÄËøëÁöÑÊ£ÄÊü•ÁÇπ CheckPointHash common.Hash `json:"checkPointHash"` // ÁîüÊàêÂø´ÁÖßÁöÑBlock hash Signers map[common.Address]struct&#123;&#125; `json:"signers"` // ÂΩìÂâçÁöÑÊéàÊùÉÁî®Êà∑ Recents map[uint64]common.Address `json:"recents"` // ÊúÄËøëÁ≠æÂêçËÄÖ spam Tally map[common.Address]Tally `json:"tally"` // ÁõÆÂâçÁöÑËÆ°Á•®ÊÉÖÂÜµ&#125; Êé•‰∏ãÊù•Áúã‰∏Ä‰∏ã‰ª£Á†ÅÂÆûÁé∞ÔºåÂÖ∂‰∏≠HpbNodeCheckpointInterval==200 Â¶ÇÊûúnumber==0ÔºåÂ∞±ÂÖàÁîüÊàê‰∏Ä‰∏™ÂàùÂßãÂø´ÁÖßÂπ∂ËøîÂõû Â¶ÇÊûúnumber&lt;200ÔºåÂ∞±‰ªéÁºìÂ≠ò/Êï∞ÊçÆÂ∫ì‰∏≠ÂèñÂá∫ÂàùÂßãÂø´ÁÖßÔºåÂ¶ÇÊûúÂèñÂá∫Â§±Ë¥•ÔºåÂàôÁîüÊàê‰∏Ä‰∏™ÂàùÂßãÂø´ÁÖßÂπ∂ËøîÂõû ÂÖ∂‰ªñÊÉÖÂÜµÂ∞±ÊòØnumber&gt;=200ÔºåÂ¶ÇÊûúnumberÊ≠£Â•ΩÊòØ200ÁöÑÊï¥Êï∞ÂÄçÊï∞ÁöÑËØùÔºåÂàôÁîüÊàêÂø´ÁÖßÔºåÂê¶Âàô‰ªéÁºìÂ≠ò/Êï∞ÊçÆÂ∫ì‰∏≠Ëé∑Âèñ‰∏ä‰∏ÄÊ¨°ÁöÑÂø´ÁÖßÔºåÂ¶ÇÊûúËé∑ÂèñÂ§±Ë¥•ÂàôÈáçÊñ∞ÁîüÊàê‰∏ä‰∏ÄÊ¨°ÁöÑÂø´ÁÖß„ÄÇ‰∏æ‰∏™Ê†óÂ≠êÔºånumber=666ÔºåÂàôËé∑Âèñnumber=600ÁöÑÂø´ÁÖßÔºåÂ¶ÇÊûúnumber=800ÔºåÂàôÁîüÊàêÊñ∞ÁöÑÂø´ÁÖß„ÄÇÂæàÊòéÊòæÈó¥ÈöîÁõ∏ÂΩì‰∫é‰ªé0ÂºÄÂßãÁÆóÁöÑÔºåÂπ∂‰∏çÊòØÊúÄËøëÁöÑ200‰∏™Âùó„ÄÇ‰ΩÜÊòØ„ÄÇ„ÄÇ„ÄÇÂæÄ‰∏ãÁúãnumberÊòØÊÄé‰πà‰ΩøÁî®ÁöÑ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364func GetHpbNodeSnap(db hpbdb.Database, recents *lru.ARCCache, signatures *lru.ARCCache, config *config.PrometheusConfig, chain consensus.ChainReader, number uint64, hash common.Hash, parents []*types.Header) (*snapshots.HpbNodeSnap, error) &#123; // È¶ñÊ¨°Ë¶ÅÂàõÂª∫ if number == 0 &#123; if snapg, err := GenGenesisSnap(db, recents, signatures, config, chain); err == nil &#123; return snapg, err &#125; &#125; //ÂâçÂçÅËΩÆ‰∏ç‰ºöËøõË°åÊäïÁ•®ÔºåÂâç10ËΩÆÈááÁî®Âå∫Âùó0Êó∂ÂÄôÁöÑÊï∞ÊçÆ //ÂÖàËé∑ÂèñÁºìÂ≠òÔºåÂ¶ÇÊûúÁºìÂ≠ò‰∏≠Ê≤°ÊúâÂàôËé∑ÂèñÊï∞ÊçÆÂ∫ìÔºå‰∏∫‰∫ÜÊèêÂçáÈÄüÂ∫¶ //if(true)&#123; if number &lt; consensus.HpbNodeCheckpointInterval &#123; genesis := chain.GetHeaderByNumber(0) hash := genesis.Hash() // ‰ªéÁºìÂ≠ò‰∏≠Ëé∑Âèñ if snapcd, err := GetDataFromCacheAndDb(db, recents, signatures, config, hash); err == nil &#123; log.Debug("HPB_VOTINGÔºö Loaded voting Hpb Node Snap form cache and db", "number", number, "hash", hash) return snapcd, err &#125; else &#123; if snapg, err := GenGenesisSnap(db, recents, signatures, config, chain); err == nil &#123; log.Debug("HPB_VOTINGÔºö Loaded voting Hpb Node Snap form genesis snap", "number", number, "hash", hash) return snapg, err &#125; &#125; &#125; // ÂºÄÂßãËÄÉËôë10ËΩÆ‰πãÂêéÁöÑÊÉÖÂÜµÔºåÂæÄÂâçÂõûÊ∫Ø3ËΩÆÔºå‰ª•‰øùËØÅ‰∏ÄËá¥ÊÄß„ÄÇ // ÂºÄÂßãËÆ°ÁÆóÊúÄÂêé‰∏ÄÊ¨°ÁöÑÁ°ÆËÆ§Âå∫Âùó latestCheckPointNumber := uint64(math.Floor(float64(number/consensus.HpbNodeCheckpointInterval))) * consensus.HpbNodeCheckpointInterval //log.Error("Current latestCheckPointNumber in hpb voting:",strconv.FormatUint(latestCheckPointNumber, 10)) header := chain.GetHeaderByNumber(uint64(latestCheckPointNumber)) latestCheckPointHash := header.Hash() if number%consensus.HpbNodeCheckpointInterval != 0 &#123; if snapcd, err := GetDataFromCacheAndDb(db, recents, signatures, config, latestCheckPointHash); err == nil &#123; //log.Info("##########################HPB_VOTINGÔºö Loaded voting Hpb Node Snap form cache and db", "number", number, "latestCheckPointNumber", latestCheckPointNumber) return snapcd, err &#125; else &#123; if snapa, err := snapshots.CalculateHpbSnap(uint64(1), signatures, config, number, latestCheckPointNumber, latestCheckPointHash, chain); err == nil &#123; //log.Info("@@@@@@@@@@@@@@@@@@@@@@@@HPB_VOTINGÔºö CalculateHpbSnap", "number", number, "latestCheckPointNumber", latestCheckPointNumber) if err := StoreDataToCacheAndDb(recents, db, snapa, latestCheckPointHash); err != nil &#123; return nil, err &#125; return snapa, err &#125; &#125; &#125; else &#123; if snapa, err := snapshots.CalculateHpbSnap(uint64(1), signatures, config, number, latestCheckPointNumber, latestCheckPointHash, chain); err == nil &#123; //log.Info("@@@@@@@@@@@@@@@@@@@@@@@@HPB_VOTINGÔºö CalculateHpbSnap", "number", number, "latestCheckPointNumber", latestCheckPointNumber) //Êñ∞ËΩÆÊ¨°ËÆ°ÁÆóÂÆåÈ´òÊÄßËÉΩËäÇÁÇπÁ´ãÂç≥Êõ¥Êñ∞ËäÇÁÇπÁ±ªÂûã //prometheus.SetNetNodeType(snapa) if err := StoreDataToCacheAndDb(recents, db, snapa, latestCheckPointHash); err != nil &#123; return nil, err &#125; return snapa, err &#125; else &#123; return nil, err &#125; &#125; return nil, nil&#125; ÂÖ∑‰ΩìÁîüÊàêÂø´ÁÖßÁöÑÁÆóÊ≥ïÊòØÂú®CalculateHpbSnap‰∏≠ÂÆûÁé∞ÁöÑÔºå‰πüÂ∞±ÊòØÂå∫ÂùóÈìæÊ†∏ÁöÑÂÖ±ËØÜÁÆóÊ≥ï„ÄÇÂÖàÁúã‰∏Ä‰∏ãÂèÇÊï∞Âê´ÊÑèÔºöÂ≠óÊÆµ|Á±ªÂûã|Âê´‰πâ|Â§áÊ≥®-|-|-|-index | |ÊäïÁ•®ËΩÆÊ¨°ÔºåCalculateHpbSnapË∞ÉÁî®Êó∂ÊòØÁ¨¨‰∏ÄÊ¨°ÔºåÊâÄ‰ª•‰º†1 |*lru | |ÊúÄËøëÁöÑÁ≠æÂêçÔºå‰ΩøÁî®ARCÁÆóÊ≥ïÂÆûÁé∞ |config | |ÂÖ±ËØÜÈÖçÁΩÆÔºåPrometheusÁöÑÂ±ûÊÄß |number | |Âå∫ÂùóÂ∫èÂè∑ |latestCheckPointNum |ÊúÄËøëÂ∫îËØ•ÁîüÊàêÂø´ÁÖßÂØπÂ∫îÁöÑÂå∫ÂùóÂ∫èÂè∑Ôºå‰πüÂ∞±ÊòØ200ÁöÑÊï¥Êï∞ÂÄç | |latestCheckPointHash |ÊúÄËøëÂ∫îËØ•ÁîüÊàêÂø´ÁÖßÂØπÂ∫îÁöÑÂå∫ÂùóÂìàÂ∏å | |chain |Âå∫ÂùóÈìæÊåáÈíà | | Âø´ÁÖßÁîüÊàê‰∏ªË¶ÅÈÄöËøánumberÂèÇÊï∞ÈÄâ‰∏æÂá∫‰∏ÄÂÆöÁöÑÂå∫ÂùóÁîüÊàêËäÇÁÇπÔºåËøôÂùóË¶Å‰∏ªÁÆóÊ≥ïÂÆûÁé∞Ôºå‰∏∫‰∫ÜÊñπ‰æøÁêÜËß£ÔºåÂÅáËÆæÂú®ÁîüÊàêÂå∫ÂùóÊó∂ÁöÑnumber‰∏∫210„ÄÅ650„ÄÅ1875Ôºå‰πüÂ∞±ÊòØË∞ÉÁî®GetHpbNodeSnapÊñπÊ≥ï‰º†ÂÖ•ÁöÑnumberÔºåË°®Á§∫‰∏∫{210|650|1875}ÔºåÊúÄÂêéËÆ°ÁÆóÂæóÂà∞latestCheckPointNumÊòØ{200|600|1800}ÔºåÂ∞ÜËøô‰∏§‰∏™ÂèÇÊï∞‰º†ÂÖ•CalculateHpbSnapÔºåÊ≥®ÊÑèÊ≠§Êó∂index‰º†ÂÖ•ÁöÑÊòØ1 ÈÄâÂá∫‰∏ÄÂÆöËåÉÂõ¥ÂÜÖÁöÑÂå∫ÂùóÂ§¥ÈõÜÂêàÔºåÂå∫Èó¥ÁïåÁ∫ø‰∏∫fromÂà∞latestCheckPointNum-100ÔºåfromËÆ°ÁÆóÊñπÊ≥ïÊòØlatestCheckPointNum - index*consensus.HpbNodeCheckpointIntervalÔºåÊâÄ‰ª•ÂèØ‰ª•ÂæóÂà∞ÁöÑËåÉÂõ¥ÊòØ{0-100|400-500|1600-1700} ÈÄöËøáchainÂèñÂá∫{0-100|400-500|1600-1700}ËåÉÂõ¥ÂÜÖÊâÄÊúâÂå∫ÂùóÂ§¥ÔºåËµãÁªôheadersÂèòÈáèÔºå‰∏ÄÂÖ±100‰∏™Âå∫ÂùóÂ§¥ÔºàÁêÜÊÉ≥ÊÉÖÂÜµ‰∏ãÔºâ„ÄÇÂ¶ÇÊûúÂú®Ëé∑ÂèñÂ§¥ÁöÑÊó∂ÂÄôÁ¥ØËÆ°Âá∫‰∫Ü20Ê¨°Ê≤°ÂèñÂà∞ÔºåÁõ¥Êé•ËøîÂõûÂºÇÂ∏∏errors.New(‚Äúget hpb snap but missing header‚Äù) ÂØπÂå∫ÂùóÂ§¥ÈõÜÂêàheadersËøõË°åËøûÁª≠ÊÄßÊ£ÄÊü•Ôºå‰πüÂ∞±ÊòØÊâÄÊúâÂå∫ÂùóÂ§¥ÁöÑnumberÂøÖÈ°ªÊòØËøûÁª≠ÁöÑÔºåÂê¶ÂàôËøîÂõûÂºÇÂ∏∏ ÂàùÂßãÂåñÂø´ÁÖßÂØπË±°snapÔºåÂπ∂Â°´Ë£ÖsnapÁöÑTallyÂ±ûÊÄßÔºåÊ≥®ÊÑèsnapÁöÑTallyÊòØmap[common.Address]TallyÁ±ªÂûãÁöÑÔºåkeyÊòØaddÔºåvalueÊòØTallyÔºåËÄåvalueÁöÑÁ±ªÂûãTallyÊú¨Ë∫´ÂèàÊòØ‰∏Ä‰∏™ÁªìÊûÑ‰Ωì„ÄÇÂ°´Ë£ÖËøáÁ®ãÂ∞±ÊòØÊääheaderÂØπÂ∫îÁöÑÊâÄÊúâaddress‰Ωú‰∏∫ÈîÆputÂà∞map‰∏≠ÔºåvalueÊòØTallyÁªìÊûÑ‰Ωì„ÄÇ *TallyÂàùÂßãÂÄºÊòØVoteNumbers: 1, VoteIndexs: header.VoteIndex, VotePercent: header.VoteIndex, *Â¶ÇÊûúkeyÈáçÂ§çÂá∫Áé∞ÔºåÂàôÈúÄË¶ÅÊääVoteNumbersÂíåVoteIndexsÂØπÂ∫îÁöÑÊñ∞ÊóßÂÄºËøõË°åÁ¥ØÂä†ÔºåÈáçÊñ∞ËÆ°ÁÆóVotePercent=VoteIndexs/VoteNumbersÂπ∂ËµãÂÄºËøôÊ†∑Â∞±ÂæóÂà∞‰∫Ü100‰∏Ä‰∏™headerÂØπÂ∫îÁöÑaddressÁöÑTallyÔºåÂΩìÁÑ∂ÁªìÊûúÂèØËÉΩ‰ºöÂ∞ë‰∫é100‰∏™ÔºåÂõ†‰∏∫ÊúâÈáçÂ§çÁöÑ„ÄÇ Â∞ÜmapÂÜçÂ§çÂà∂Âà∞‰∏¥Êó∂ÂèòÈáètallytemp‰∏≠ÔºåÂàÜÂà´ÊåâÁÖßCandAddressÂíåÁôæÂàÜÊØîVotePercent‰ªéÂ∞èÂà∞Â§ßËøõË°åÊéíÂ∫èÔºåÊéíÂ∫èÁªìÊûú‰øùÂ≠òÂà∞ÂèòÊõ¥finaltally‰∏≠ Êé•‰∏ãÊù•ÈÄöËøáÂΩìÂâçÈ´òÊÄßËÉΩËäÇÁÇπÊï∞ÈáèÊù•Ëß£ÂÜ≥ÊòØÂê¶ÈúÄË¶ÅÂÜçÊ¨°ËøõË°åËé∑Âèñ‰∏Ä‰∫õheadersÊù•ËøõË°åÊäïÁ•®ËÆ°ÁÆóÔºå‰πüÂ∞±ÊòØ‰∏äËæπ1-5Ê≠•È™§ Á≥ªÁªüÈªòËÆ§ÁöÑÈ´òÊÄßËÉΩËäÇÁÇπ‰∏™Êï∞ÊòØconsensus.HpbNodenumber=31‰∏™ÔºåÂ¶ÇÊûúfinaltallyÈïøÂ∫¶Â§ßÁ≠â‰∫é31ÔºåÂàôÊääÊéíÂ∫èÂêéÁöÑÂêéËæπÁöÑ31‰∏™ËäÇÁÇπÂú∞ÂùÄÊ∑ªÂä†Âà∞snap.Signers‰∏≠ÔºåÂç≥ÊéàÊùÉÁî®Êà∑ÔºåË°®Á§∫ÂèØ‰ª•ËøõË°åÊåñÁüø„ÄÇ Â¶ÇÊûúfinaltallyÂ∞è‰∫é31ÔºåËÄå‰∏îÂ∑≤ÁªèËøõË°å‰∫Ü4Ê¨°ÊäïÁ•®ËÆ°ÁÆóÔºà1-5Ê≠•È™§ÔºâÔºåÂ∞±Êääfinaltally‰∏≠ÊâÄÊúâÁöÑÂú∞ÂùÄËøõË°åÊéàÊùÉ Â¶ÇÊûúfinaltallyÂ∞è‰∫é31ÔºåËÄå‰∏îËøõË°å‰∫Ü‰∏çÂà∞4Ê¨°ÊäïÁ•®ËÆ°ÁÆóÔºåÂàôÂæÄÂâçÂõûÊ∫ØÂÜçÂèñÂá∫‰∏Ä‰∫õÂå∫ÂùóÂ§¥ÔºàÂú∞ÂùÄÔºâËøõË°åÊäïÁ•®„ÄÇ‰ΩÜÊòØÂæÄÂâçÂõûÊ∫ØÊúâ‰∏™Êù°‰ª∂ÔºåÂ∞±ÊòØÂâçËæπÊúâË∂≥Â§üÁöÑÂå∫ÂùóÂ§¥ÂèØ‰ª•Ëé∑ÂèñÔºåÂ¶ÇÊûúÂâçËæπÁöÑÂå∫ÂùóÂ§¥‰∏çÂ§üÂÖÖË∂≥‰∫ÜÔºåÂàôÂè™ËÉΩÊääÂΩìÂâçfinaltallyÁöÑÂú∞ÂùÄÂÖ®ÈÉ®ÊéàÊùÉ‰∫Ü„ÄÇÊòØÂê¶ÂèØ‰ª•ÂæÄÂâçÂõûÊ∫ØÁöÑÂà§Êñ≠Êù°‰ª∂ÊòØindex&lt;number/200ÔºåÊØîÂ¶ÇÁ¨¨‰∏ÄËΩÆÊäïÁ•®ÁöÑÊó∂ÂÄônumber={210|650|1875}ÔºåÊäï‰∫Ü{0-100|400-500|1600-1700}Âå∫Èó¥ÁöÑËäÇÁÇπÂú∞ÂùÄÔºåÊúÄÁªàÁªìÊûú‰∏çÂ§ü31‰∏™È´òÊÄßËÉΩËäÇÁÇπÔºåÈÇ£‰πàËøõË°åÁ¨¨‰∫åËΩÆÊäïÁ•®„ÄÇ2&lt;210/200‰∏∫falseÔºåËøôÁßçÊÉÖÂÜµÂ∞±‰∏çËÉΩÂæÄÂâçÂõûÊ∫Ø‰∫ÜÔºõ2&lt;650/200‰∏∫trueÔºåÂàôÂèØ‰ª•ÂõûÊ∫ØÔºåÁÑ∂ÂêéÈÄíÂΩíË∞ÉÁî®CalculateHpbSnapÊñπÊ≥ïÔºåËøôÊó∂‰º†ÂÖ•ÁöÑindex=2ÔºånumberÂíålatestCheckPointNumÂàÜÂà´ÂêëÂâçÁßª200‰∏™Âçï‰ΩçÔºåÂç≥number={-|450|1675}ÔºålatestCheckPointNum={-|400|1600}ÔºåÈÄíÂΩíÂêéÂèØÂæóËåÉÂõ¥‰∏∫ {-|200-300|1400-1500}„ÄÇÂèØ‰ª•ÂèëÁé∞ÊØèÊ¨°‰∏≠Èó¥Èöî100‰∏™Âçï‰Ωç„ÄÇ Âú®ËøõË°å‰∫Ü‰∏ã‰∏ÄÊäïÁ•®ËÆ°ÁÆóÔºàÈÄíÂΩíË∞ÉÁî®Ôºâ‰πãÂêéÔºåÂæóÂà∞Êñ∞ÁöÑËäÇÁÇπÂú∞ÂùÄÈõÜÂêàÔºåÊääÂÖ∂‰∏≠Â∑≤ÁªèÂ≠òÂú®‰∫é‰∏ä‰∏ÄÊ¨°finaltally‰∏≠ÁöÑÂú∞ÂùÄÂà†Èô§ÊéâÔºåÊ≠§Êó∂Â¶ÇÊûúÊñ∞ÁöÑËäÇÁÇπÂú∞ÂùÄ‰∏Ä‰∏™‰πüÊ≤°ÊúâÔºåÂàôÁªìÊùüÊäïÁ•®ÔºåÂ¶ÇÊûúËøòÊúâÁöÑËØùÂ∞±ÂØπÊñ∞ÁöÑËäÇÁÇπÂú∞ÂùÄÈõÜÂêàËøõË°åÊéíÂ∫è ÊéíÂ∫èÂÆå‰∫Ü‰πãÂêéÔºåÂ¶ÇÊûúÊñ∞ÊóßÈõÜÂêàÁöÑÈïøÂ∫¶ÂíåÂ∞èÁ≠â‰∫é31ÔºåÂ∞±ÊääÊñ∞ÊóßÈõÜÂêàÂêàÂπ∂‰∏Ä‰∏ãÔºåÂê¶ÂàôÁöÑËØùÊääÊñ∞ÈõÜÂêàÁöÑÊï∞ÊçÆË°•ÂÖÖÂà∞ÊóßÈõÜÂêà‰∏≠ÔºåÁõ¥Âà∞ÊóßÈõÜÂêàÂ§ü31‰∏™ËäÇÁÇπ‰∫Ü„ÄÇ ÊúÄÂêéÊääzeroaddrÂú∞ÂùÄÂà†Èô§Êéâ„ÄÇÔºà‰∏çÊòØÂæàÊ∏ÖÊ•öÔºå‰ªÄ‰πàÊÉÖÂÜµ‰∏ã‰ºöÊúâÂ≠òÂú®zeroaddrÂú∞ÂùÄÔºâ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179func CalculateHpbSnap(index uint64, signatures *lru.ARCCache, config *config.PrometheusConfig, number uint64, latestCheckPointNum uint64, latestCheckPointHash common.Hash, chain consensus.ChainReader) (*HpbNodeSnap, error) &#123; // Allow passing in no headers for cleaner code var headers []*types.Header // ÂºÄÂßãËé∑Âèñ‰πãÂâçÁöÑÊâÄÊúâheader var from = latestCheckPointNum - index*consensus.HpbNodeCheckpointInterval if from == 0 &#123; from = from + 1 &#125; for i := from; i &lt; latestCheckPointNum-100; i++ &#123; loopcount := 0 GETCOUNT: header := chain.GetHeaderByNumber(uint64(i)) if header != nil &#123; headers = append(headers, header) &#125; else &#123; if loopcount &gt; 20 &#123; return nil, errors.New("get hpb snap but missing header") &#125; loopcount += 1 goto GETCOUNT //log.Error("get hpb snap but missing header", "number", i) &#125; &#125; // Â¶ÇÊûúÂ§¥ÈÉ®‰∏∫Á©∫ÔºåÁõ¥Êé•ËøîÂõû if len(headers) == 0 &#123; return nil, errors.New("Calculate Hpb Snap headers is 0 ") &#125; // Ê£ÄÊü•ÊâÄÊúâÁöÑÂ§¥ÈÉ®ÔºåÊ£ÄÊü•ËøûÁª≠ÊÄß for i := 0; i &lt; len(headers)-1; i++ &#123; if headers[i+1].Number.Uint64() != headers[i].Number.Uint64()+1 &#123; return nil, consensus.ErrInvalidVotingChain &#125; &#125; //signers := make([]common.Address, 0, consensus.HpbNodenumber) snap := NewHistorysnap(config, signatures, number, latestCheckPointNum, latestCheckPointHash, nil) snap.Tally = make(map[common.Address]Tally) for _, header := range headers &#123; VoteNumberstemp := big.NewInt(0) VoteIndexstemp := big.NewInt(0) VotePercenttemp := big.NewInt(0) //Á•®ÁöÑÊï∞Èáè‰∏éÊÄßËÉΩ‰πãÈó¥ÁöÑÂÖ≥Á≥ªÔºåËé∑ÂèñÁ•®ÁöÑÊï∞ÈáèË°®Á§∫Âú®Á∫øÊó∂Èó¥ÈïøÂ∫¶ÔºåÊâÄ‰ª•Â∫îËØ•ÈÄâÊã©Âú®Á∫øÊó∂Èó¥ÈïøÊÄßËÉΩÂèàÂ•ΩÁöÑËäÇÁÇπ„ÄÇ if old, ok := snap.Tally[header.CandAddress]; ok &#123; VoteNumberstemp.Add(old.VoteNumbers, big.NewInt(1)) VoteIndexstemp.Add(old.VoteIndexs, header.VoteIndex) VotePercenttemp.Div(VoteIndexstemp, VoteNumberstemp) snap.Tally[header.CandAddress] = Tally&#123; VoteNumbers: VoteNumberstemp, VoteIndexs: VoteIndexstemp, VotePercent: VotePercenttemp, CandAddress: header.CandAddress, &#125; &#125; else &#123; snap.Tally[header.CandAddress] = Tally&#123; VoteNumbers: big.NewInt(1), VoteIndexs: header.VoteIndex, VotePercent: header.VoteIndex, CandAddress: header.CandAddress, &#125; &#125; &#125; var tallytemp []Tally for _, v := range snap.Tally &#123; tallytemp = append(tallytemp, v) &#125; for i := 0; i &lt; len(snap.Tally); i++ &#123; for j := 0; j &lt; len(snap.Tally)-i-1; j++ &#123; if bytes.Compare(tallytemp[j].CandAddress[:], tallytemp[j+1].CandAddress[:]) &gt; 0 &#123; tallytemp[j], tallytemp[j+1] = tallytemp[j+1], tallytemp[j] &#125; &#125; &#125; for i := 0; i &lt; len(snap.Tally); i++ &#123; for j := 0; j &lt; len(snap.Tally)-i-1; j++ &#123; if tallytemp[j].VotePercent.Cmp(tallytemp[j+1].VotePercent) &gt; 0 &#123; tallytemp[j], tallytemp[j+1] = tallytemp[j+1], tallytemp[j] &#125; else if (tallytemp[j].VotePercent.Cmp(tallytemp[j+1].VotePercent) == 0) &amp;&amp; (bytes.Compare(tallytemp[j].CandAddress[:], tallytemp[j+1].CandAddress[:]) &gt; 0) &#123; tallytemp[j], tallytemp[j+1] = tallytemp[j+1], tallytemp[j] &#125; &#125; &#125; finaltally := make([]common.Address, 0, len(tallytemp)) for _, v := range tallytemp &#123; finaltally = append(finaltally, v.CandAddress) &#125; var hpnodeNO int if len(finaltally) &gt;= consensus.HpbNodenumber &#123; hpnodeNO = consensus.HpbNodenumber goto END &#125; else &#123; if index == consensus.Hpcalclookbackround+1 &#123; //look back round is consensus.Hpcalclookbackround hpnodeNO = len(finaltally) goto END &#125; index = index + 1 if index &lt; uint64(math.Floor(float64(number/consensus.HpbNodeCheckpointInterval))) &#123; // ÂæÄÂâçÂõûÊ∫Ø //log.Error("-------- go back for last snap------------", "index", index) header := chain.GetHeaderByNumber(uint64(latestCheckPointNum - consensus.HpbNodeCheckpointInterval)) latestCheckPointHash := header.Hash() snaptemp, err := CalculateHpbSnap(index, signatures, config, number-consensus.HpbNodeCheckpointInterval, latestCheckPointNum-consensus.HpbNodeCheckpointInterval, latestCheckPointHash, chain) if err != nil &#123; log.Debug("recursive call CalculateHpbSnap fail", "err", err) hpnodeNO = len(finaltally) goto END &#125; //get last snap hp nodes, set in map hpsmaptemp := make(map[common.Address]struct&#123;&#125;) lastsnap := snaptemp.GetHpbNodes() for _, v := range lastsnap &#123; hpsmaptemp[v] = struct&#123;&#125;&#123;&#125; &#125; //delete tallytemp.CandAddress in the map for _, v := range finaltally &#123; if _, ok := hpsmaptemp[v]; ok &#123; delete(hpsmaptemp, v) &#125; &#125; if 0 == len(hpsmaptemp) &#123; hpnodeNO = len(finaltally) goto END &#125; //order the hpsmaptemp by put it into []common.address delhpsmap := make([]common.Address, len(hpsmaptemp)) for key, _ := range hpsmaptemp &#123; delhpsmap = append(delhpsmap, key) &#125; //sort by addr if 1 &lt; len(delhpsmap) &#123; for i := 0; i &lt; len(delhpsmap); i++ &#123; for j := 0; j &lt; len(delhpsmap)-i-1; j++ &#123; if bytes.Compare(delhpsmap[j][:], delhpsmap[j+1][:]) &gt; 0 &#123; delhpsmap[j], delhpsmap[j+1] = delhpsmap[j+1], delhpsmap[j] &#125; &#125; &#125; &#125; //calc how many last snap hps needing to add the latest snap if len(finaltally)+len(delhpsmap) &gt; consensus.HpbNodenumber &#123; for i := 0; i &lt; consensus.HpbNodenumber-len(finaltally); i++ &#123; finaltally = append(finaltally, delhpsmap[i]) &#125; &#125; else &#123; for i := 0; i &lt; len(delhpsmap); i++ &#123; finaltally = append(finaltally, delhpsmap[i]) &#125; &#125; &#125; hpnodeNO = len(finaltally) &#125;END: for i := len(finaltally) - 1; i &gt; len(finaltally)-hpnodeNO-1; i-- &#123; snap.Signers[finaltally[i]] = struct&#123;&#125;&#123;&#125; &#125; zeroaddr := common.HexToAddress("0x0000000000000000000000000000000000000000") if _, ok := snap.Signers[zeroaddr]; ok &#123; delete(snap.Signers, zeroaddr) &#125; return snap, nil&#125; Âú®Á°ÆÂÆöËäÇÁÇπÂú∞ÂùÄÂå∫Èó¥ÁöÑÈÄªËæëÊØîËæÉÁÆÄÂçï,Â∞±ÊòØ‰ªéÂâçÂæÄÂêéÔºåÈöî100,Ê†áËÆ∞100‰∏™‰∏∫ÂèØÂèñÁöÑ,ÁÑ∂Âêé‰ªéÂêéÂæÄÂâçÂèñÂÄíÊï∞Á¨¨‰∏Ä‰∏™100ÔºåÂéªÈáçÂêéÂ§ü31‰∏™Â∞±ÂèØ‰ª•‰∫ÜÔºå‰∏çÂ§ü‰∫ÜÂÜçÂèñÂÄíÊï∞Á¨¨2‰∏™100„ÄÇ‰ª£Á†ÅÁÆóÊ≥ïÂÜôÁöÑÂ§çÊùÇ‰∫ÜÔºåËøòÁî®‰∫ÜÈÄíÂΩí„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇVoteIndexsËøô‰∏™ÊòØ‰ªéÂå∫ÂùóÂ§¥‰∏≠ÂèñÂá∫Êù•ÁöÑÔºåÊ≤°ÊâæÂà∞ÊúÄÂàùÊòØÂú®Âì™ÂÑøsetËøõÂéªÁöÑ„ÄÇÁúüÁ¥Ø‰∫∫‚Ä¶‚Ä¶‚Ä¶]]></content>
      <categories>
        <category>HPBÊ∫êÁ†ÅËß£ËØª</category>
      </categories>
      <tags>
        <tag>HPB</tag>
        <tag>Âå∫ÂùóÈìæ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GO-HPBÊ∫êÁ†ÅËß£ËØª--ÊåñÁüøÊµÅÁ®ãÔºàÂõõÔºâ]]></title>
    <url>%2F2019%2F07%2F21%2FGO-HPB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%8C%96%E7%9F%BF%E6%B5%81%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Êé•ÁùÄ‰∏ä‰∏ÄÁ´†ÔºåÊàë‰ª¨ÁúãÂà∞‰∫ÜËøôÁ´†Êù•Áúã‰∫Ügo self.mine(work, self.quitCurrentOp)ËøôÈÉ®ÂàÜ‰ª£Á†ÅÔºåÁé∞Âú®Êù•Áúã‰∏ãÂÖ∑‰ΩìÊåñÁüøÁÆóÊ≥ïÁöÑÊµÅÁ®ã„ÄÇmineÊñπÊ≥ï‰∏≠Ë∞ÉÁî®engine.GenBlockWithSigÊñπÊ≥ïÔºåËøîÂõûÁöÑresultÁªìÊûú‰º†ÈÄíÁªôreturnChÈÄöÈÅìÔºåËÄåreturnChÈÄöÈÅìÁöÑËé∑ÂèñÂ∑•‰ΩúÊòØÂú®worker‰∏≠ËøõË°åÂ§ÑÁêÜÁöÑ„ÄÇ‰∏ä‰∏ÄËäÇÊàë‰ª¨ÁêÜ‰∫Ü‰∏Ä‰∏ãproducerÁªëÂÆöCpuAgentÁöÑÊµÅÁ®ãÔºåÂú®worker.NewÁöÑÊó∂ÂÄôÔºåÈÄöËøágo worker.handlerSelfMinedBlock()ËøôË°å‰ª£Á†ÅÂêØ‰∫Ü‰∏Ä‰∏™ÂçèÁ®ãÂéªËé∑ÂèñÈÄöÈÅìÈáåÁöÑÊåñÁüøÁªìÊûú„ÄÇ 1234567891011func (self *CpuAgent) mine(work *Work, stop &lt;-chan struct&#123;&#125;) &#123; if result, err := self.engine.GenBlockWithSig(self.chain, work.Block, stop); result != nil &#123; log.Info("Successfully sealed new block", "number -&gt; ", result.Number(), "hash -&gt; ", result.Hash(),"difficulty -&gt; ",result.Difficulty()) self.returnCh &lt;- &amp;Result&#123;work, result&#125; &#125; else &#123; if err != nil &#123; log.Warn("Block sealing failed", "err", err) &#125; self.returnCh &lt;- nil &#125;&#125; ÁîüÊàêÂå∫ÂùóÁöÑËøáÁ®ãÔºö Êï∞ÊçÆÂêàÊ≥ïÊÄßÊ†°È™å Ëé∑ÂèñÁ≠æÂêçËÄÖsignerÂíåÁ≠æÂêçÊñπÊ≥ïsignFnÔºåËøô‰∏§‰∏™Êï∞ÊçÆÊòØÂú®ÊåñÁüøÊµÅÁ®ãÔºà‰∫åÔºâ‰∏≠ÁöÑStartMiningÊñπÊ≥ï‰∏≠ËÆæÁΩÆÁöÑÔºå‰ª£Á†ÅÊòØpromeengine.Authorize(eb, wallet.SignHash)ÔºåÂç≥signerÊòØÂΩìÂâçËäÇÁÇπÁöÑÊåñÁüøÂú∞ÂùÄcoinbaseÔºåsignFnÊòØÂØπÂ∫îÈí±ÂåÖÁöÑÁ≠æÂêçÊñπÊ≥ïÔºåÂç≥keystoreWalletÁ±ªÁöÑÁ≠æÂêçÊñπÊ≥ï voting.GetHpbNodeSnapÊòØËé∑ÂèñÈ´òÊÄßËÉΩËäÇÁÇπÂàóË°®ÔºåÂÖ∂‰∏≠ÊúâÈáçÊñ∞ÊäïÁ•®ËäÇÁÇπÁöÑËøáÁ®ãÔºåÊäïÁ•®Ëøô‰∏™Êú∫Âà∂ÂçïÁã¨Ëß£ËØªÔºåËøôÈáåÂ∞±ÂÖà‰∏çËØ¥‰∫Ü„ÄÇ ËÆæÁΩÆÊú¨Âú∞ËäÇÁÇπÁ±ªÂûãÔºåÊòØÈ´òÊÄßËÉΩËäÇÁÇπËøòÊòØÂÄôÈÄâËäÇÁÇπ Â¶ÇÊûúËá™Â∑±ÁöÑÂΩìÂâçËäÇÁÇπ‰∏çÊòØÂåÖÂê´Âú®È´òÊÄßËÉΩËäÇÁÇπ‰∏≠ÔºåÂàôËøîÂõûÈîôËØØconsensus.ErrUnauthorized Êé•ÁùÄË¶ÅÂà§Êñ≠‰∏Ä‰∏ãËá™Â∑±ÂΩìÂâçËäÇÁÇπÊòØÂê¶ËΩÆÂà∞ËøõË°åÁ≠æÂêçÔºàÊåñÁüøÔºâÔºåÂ¶ÇÊûúÊ≤°ËΩÆÂà∞ÔºåÈúÄË¶ÅÈÄöËøáÈ´òÊÄßËÉΩËäÇÁÇπÂàóË°®‰∏≠Ëá™Â∑±ÁöÑ‰ΩçÁΩÆÂíåÊ≠£Âú®ÊåñÁüøÁöÑ‰ΩçÁΩÆ‰∏§‰∏™ÂÖ≥ÈîÆÂèÇÊï∞ËÆ°ÁÆóÂá∫Ëá™Â∑±ÈúÄË¶ÅÁ≠âÂæÖÁöÑ‰∏Ä‰∏™Êó∂Èó¥ÊÆµÔºå Êó∂Èó¥Âà∞‰∫ÜÁöÑËØùÂ∞±ËøõË°åÁ≠æÂêçÔºåÁ≠æÂêçÊñπÊ≥ï‰∏∫signFn,Ëøô‰∏™ÊñπÊ≥ïÁõ¥Êé•‰ΩøÁî®coinbaseÂØπÂ∫îÁöÑÁßÅÈí•ËøõË°åECDSAÁ≠æÂêç Á≠æÂêçÂÆå‰∫Ü‰πãÂêéÔºåÊääÁ≠æÂêçÁªìÊûúÊîæÁΩÆÂà∞header.ExtraÈáåÔºåÂπ∂ËøîÂõûÊúÄÁªàblock 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//ÁîüÊàêÂå∫Âùófunc (c *Prometheus) GenBlockWithSig(chain consensus.ChainReader, block *types.Block, stop &lt;-chan struct&#123;&#125;) (*types.Block, error) &#123; header := block.Header() log.Info("HPB Prometheus Seal is starting") number := header.Number.Uint64() if number == 0 &#123; return nil, consensus.ErrUnknownBlock &#125; // For 0-period chains, refuse to seal empty blocks (no reward but would spin sealing) if c.config.Period == 0 &amp;&amp; len(block.Transactions()) == 0 &#123; return nil, consensus.ErrWaitTransactions &#125; c.lock.RLock() signer, signFn := c.signer, c.signFn log.Debug("GenBlockWithSig-------------+++++ signer's address", "signer", signer.Hex(), "number", number) c.lock.RUnlock() snap, err := voting.GetHpbNodeSnap(c.db, c.recents, c.signatures, c.config, chain, number, header.ParentHash, nil) SetNetNodeType(snap) if err != nil &#123; return nil, err &#125; if _, authorized := snap.Signers[signer]; !authorized &#123; return nil, consensus.ErrUnauthorized &#125; // ËΩÆÂà∞Êàë‰ª¨ÁöÑÁ≠æÂêç delay := time.Unix(header.Time.Int64(), 0).Sub(time.Now()) if delay &lt; 0 &#123; delay = 0 header.Time = big.NewInt(time.Now().Unix()) &#125; // ÊØîËæÉÈöæÂ∫¶ÂÄºÔºåÁ°ÆÂÆöÊòØÂê¶‰∏∫ÈÄÇÂêàÁöÑÊó∂Èó¥ if header.Difficulty.Cmp(diffNoTurn) == 0 &#123; // // It's not our turn explicitly to sign, delay it a bit wiggle := time.Duration(len(snap.Signers)/2+1) * wiggleTime currentminer := new(big.Int).SetBytes(header.HardwareRandom).Uint64() % uint64(len(snap.Signers)) //miner position //log.Error("-----genblocksig---------test for waiting 8 minutes--------------", "primemineraddr", primemineraddr, "primeoffset", currentminer, "number", number) myoffset := snap.GetOffset(header.Number.Uint64(), signer) distance := int(math.Abs(float64(int64(myoffset) - int64(currentminer)))) if distance &gt; len(snap.Signers)/2 &#123; distance = len(snap.Signers) - distance &#125; if distance &gt; len(snap.Signers)/consensus.StepLength &#123; //if signers length is smaller than 3, it means myoffset smaller than currentminer have high priority delay += time.Duration(len(snap.Signers)-distance+10+rand.Intn(5)) * wiggleTime &#125; else &#123; wiggle = time.Duration(1000+rand.Intn(len(snap.Signers))) * wiggleTime delay += wiggle &#125; &#125; log.Debug("Waiting for slot to sign and propagate", "delay", common.PrettyDuration(delay), "number", number) select &#123; case &lt;-stop: return nil, nil case &lt;-time.After(delay): &#125; // Âú∞ÂùÄËµãÂÄº header.Coinbase = signer // Á≠æÂêç‰∫§ÊòìÔºåsignFn‰∏∫ÂõûÊéâÂáΩÊï∞ sighash, err := signFn(accounts.Account&#123;Address: signer&#125;, consensus.SigHash(header).Bytes()) if err != nil &#123; return nil, err &#125; //Â∞ÜÁ≠æÂêçÂêéÁöÑÁªìÊûúËøîÁªôÂà∞Extra‰∏≠ copy(header.Extra[len(header.Extra)-consensus.ExtraSeal:], sighash) return block.WithSeal(header), nil&#125; Êï¥‰∏™ÊåñÁüøÊµÅÁ®ãÂ∞±Âà∞Ê≠§ÁªìÊùü‰∫ÜÔºåÂΩìÁÑ∂ÂÖ∂‰∏≠‰ºöÊ∂âÂèä‰∏Ä‰∫õÂÖ∂‰ªñÁöÑÂäüËÉΩÁÇπÔºåÊØîÂ¶ÇP2PÔºåÊäïÁ•®Êú∫Âà∂Á≠âÔºåÂêéÁª≠ÂçïÁã¨Ëß£ËØª„ÄÇËøôÊÆµ‰ª£Á†ÅËØª‰∫ÜÂæà‰πÖÔºåË¢´ÊäïÁ•®ÈÇ£ÂùóÊêûÊ≠ª‰∫ÜÔºåËØ¥Â•ΩÁöÑPOWÂë¢ÔºüÊÄé‰πàÊ≤°ÁúãÂà∞Âë¢üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠]]></content>
      <categories>
        <category>HPBÊ∫êÁ†ÅËß£ËØª</category>
      </categories>
      <tags>
        <tag>HPB</tag>
        <tag>Âå∫ÂùóÈìæ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GO-HPBÊ∫êÁ†ÅËß£ËØª--ÊåñÁüøÊµÅÁ®ãÔºà‰∏âÔºâ]]></title>
    <url>%2F2019%2F07%2F21%2FGO-HPB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%8C%96%E7%9F%BF%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Âú®ÊåñÁüøÊµÅÁ®ãÔºà‰∏âÔºâÁöÑÊúÄÂêéÔºåÁúãÂà∞Âú®go self.mine(work, self.quitCurrentOp)‰∏≠Ë¶Å‰º†ÈÄí‰∏Ä‰∏™workÂØπË±°ËøõÂéª„ÄÇÂõ†‰∏∫ÊåñÁüøÊµÅÁ®ãÈúÄË¶Å‰ΩøÁî®Âà∞Â§ßÈáèÁöÑworkÊï∞ÊçÆÔºåÊâÄ‰ª•ÂçïÁã¨ÂàÜÊûê‰∏Ä‰∏ãworkÁöÑÊï∞ÊçÆÁªìÊûÑÂíåÂàùÂßãÂåñÊµÅÁ®ã 1234567891011121314151617181920// Work is the workers current environment and holds// all of the current state informationtype Work struct &#123; config *config.ChainConfig signer types.Signer state *state.StateDB // apply state changes here ancestors *set.Set // ancestor set (used for checking uncle parent validity) family *set.Set // family set (used for checking uncle invalidity) uncles *set.Set // uncle set tcount int // tx count in cycle Block *types.Block // the new block header *types.Header txs []*types.Transaction receipts []*types.Receipt createdAt time.Time&#125; Â≠óÊÆµ Á±ªÂûã Âê´‰πâ Â§áÊ≥® config *config.ChainConfig chainÁöÑÈÖçÁΩÆÂèÇÊï∞ signer types.Signer Á≠æÂêç state *state.StateDB ancestors *set.Set Á•ñÂÖàÂìàÂ∏åÈõÜÂêàÔºå‰πüÂ∞±ÊòØÊúÄËøëÁöÑ7‰∏™Âå∫ÂùóÁöÑÂìàÂ∏åÔºå family *set.Set ÂÆ∂ÊóèÂìàÂ∏åÈõÜÂêàÔºå‰πüÂ∞±ÊòØÊúÄËøëÁöÑ7‰∏™Âå∫ÂùóÁöÑÂìàÂ∏å‰ª•ÂèäÊØè‰∏™Âå∫ÂùóÁöÑÂèîÂå∫ÂùóÈõÜÂêàÁöÑÂìàÂ∏å uncles *set.Set ÂèîÂùóÈõÜÂêà tcount int ‰∫§ÊòìÂë®ÊúüÂÜÖÁöÑ‰∫§ÊòìÊï∞Èáè Block *types.Block header *types.Header txs []*types.Transaction receipts []*types.Receipt createdAt time.Time startNewMinerRound()ÊñπÊ≥ï‰∏ªË¶ÅÊòØÂàõÂª∫‰∫Ü‰∏Ä‰∏™workÂπ∂pushÂà∞workchÈÄöÈÅì‰∏≠ÔºåÂ§ßËá≥ÊµÅÁ®ãÊòØÔºö Á°ÆÂÆöÂå∫ÂùóÁöÑÊó∂Èó¥Êà≥ÔºåÂõ†‰∏∫‰∏ä‰∏ÄÂå∫ÂùóÂèØËÉΩÊù•Ëá™ËäÇÁÇπÂêåÊ≠•ÔºåÊâÄ‰ª•Êó∂Èó¥ÂèØËÉΩÂ≠òÂú®Â∑ÆÂºÇÔºåËøôÈáåÁ°Æ‰øù‰∫Ü‰∏§‰∏™ÁÇπÔºå‰∏ÄÊòØÊñ∞ÂùóÁöÑÊó∂Èó¥‰∏ÄÂÆöË¶ÅÊØî‰∏ä‰∏ÄÂå∫ÂùóÁöÑÊó∂Èó¥Â§ßÔºåËá≥Â∞ë1Ôºõ‰∫åÊòØÊñ∞ÂùóÁöÑÊó∂Èó¥ÂíåËá™Â∑±Á≥ªÁªüÊó∂Èó¥Â∑Æ‰∏çË¶ÅË∂ÖËøá1Ôºå‰πüÂ∞±ÊòØËØ¥ËÆ°ÁÆóÂá∫Êù•ÁöÑÊñ∞ÂùóÊó∂Èó¥Êà≥ÊØîÂΩìÂâçÊó∂Èó¥Âä†1sËøòÂ§ßÔºåÈÇ£Â∞±Âè™ËÉΩÁ≠â‰∏Ä‰ºöÂÑøÂÜçÊâßË°å‰∫Ü„ÄÇÊØîÂ¶ÇÂΩìÂâçÊó∂Èó¥ÊòØ1ÔºåÊñ∞Âå∫Êó∂Èó¥Êà≥ÊòØ8ÔºåÈÇ£‰πàÂ∞±ÈúÄË¶ÅÁ≠â7s‰∫Ü„ÄÇ ÁªÑÁªáÊñ∞ÂùóÁöÑheader ÂàùÂßãÂåñÂΩìÂâçworkÂØπË±° ÊääappendingÁöÑ‰∫§ÊòìÊâìÂåÖËøõÊù• ‰ΩøÁî®ÂÖ±ËØÜÂºïÊìéÁªÑË£ÖÊàê‰∏Ä‰∏™ÂÆåÊï¥ÁöÑÂå∫Âùó Êèê‰∫§ÊåñÁüø‰ªªÂä°work1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495func (self *worker) startNewMinerRound() &#123; self.mu.Lock() defer self.mu.Unlock() self.uncleMu.Lock() defer self.uncleMu.Unlock() self.currentMu.Lock() defer self.currentMu.Unlock() tstart := time.Now() parent := self.chain.CurrentBlock() tstamp := tstart.Unix() if parent.Time().Cmp(new(big.Int).SetInt64(tstamp)) &gt;= 0 &#123; tstamp = parent.Time().Int64() + 1 &#125; // this will ensure we're not going off too far in the future if now := time.Now().Unix(); tstamp &gt; now+1 &#123; wait := time.Duration(tstamp-now) * time.Second log.Info("Mining too far in the future", "wait", common.PrettyDuration(wait)) time.Sleep(wait) &#125; num := parent.Number() header := &amp;types.Header&#123; ParentHash: parent.Hash(), Number: num.Add(num, common.Big1), GasLimit: bc.CalcGasLimit(parent), GasUsed: new(big.Int), Extra: self.extra, Time: big.NewInt(tstamp), &#125; // Only set the coinbase if we are mining (avoid spurious block rewards) if atomic.LoadInt32(&amp;self.mining) == 1 &#123; header.Coinbase = self.coinbase &#125; pstate, _ := self.chain.StateAt(parent.Root()) if err := self.engine.PrepareBlockHeader(self.chain, header,pstate); err != nil &#123; log.Error("Failed to prepare header for mining", "err", err) return &#125; err := self.makeCurrent(parent, header) if err != nil &#123; log.Error("Failed to create mining context", "err", err) return &#125; // Create the current work task and check any fork transitions needed work := self.current //if self.config.DAOForkSupport &amp;&amp; self.config.DAOForkBlock != nil &amp;&amp; self.config.DAOForkBlock.Cmp(header.Number) == 0 &#123; // misc.ApplyDAOHardFork(work.state) //&#125; pending, err := txpool.GetTxPool().Pending() if err != nil &#123; log.Error("Failed to fetch pending transactions", "err", err) return &#125; //log.Error("----read tx from pending is ", "number is", len(pending)) txs := types.NewTransactionsByPriceAndNonce(self.current.signer, pending) work.commitTransactions(self.mux, txs, self.coinbase) // compute uncles for the new block. var ( uncles []*types.Header badUncles []common.Hash ) for hash, uncle := range self.possibleUncles &#123; if len(uncles) == 2 &#123; break &#125; if err := self.commitUncle(work, uncle.Header()); err != nil &#123; log.Trace("Bad uncle found and will be removed", "hash", hash) log.Trace(fmt.Sprint(uncle)) badUncles = append(badUncles, hash) &#125; else &#123; log.Debug("Committing new uncle to block", "hash", hash) uncles = append(uncles, uncle.Header()) &#125; &#125; for _, hash := range badUncles &#123; delete(self.possibleUncles, hash) &#125; // Create the new block to seal with the consensus engine if work.Block, err = self.engine.Finalize(self.chain, header, work.state, work.txs, uncles, work.receipts); err != nil &#123; log.Error("Failed to finalize block for sealing", "err", err) return &#125; // We only care about logging if we're actually mining. if atomic.LoadInt32(&amp;self.mining) == 1 &#123; log.Info("Commit new mining work", "number", work.Block.Number(), "txs", work.tcount, "uncles", len(uncles), "elapsed", common.PrettyDuration(time.Since(tstart))) self.unconfirmed.Shift(work.Block.NumberU64() - 1) &#125; self.push(work)&#125; 1234567891011121314151617181920212223242526272829303132makeCurrent(...)ÊñπÊ≥ïÂç≥ÂàùÂßãÂåñ‰∫Ü‰∏Ä‰∏™workÂØπË±°Ôºå‰πãÂêé‰ºöËÆæÁΩÆworkÁöÑtcount„ÄÅunclesÁ≠âÂÖ∂‰ªñÂ±ûÊÄß// makeCurrent creates a new environment for the current cycle.func (self *worker) makeCurrent(parent *types.Block, header *types.Header) error &#123; state, err := self.chain.StateAt(parent.Root()) if err != nil &#123; return err &#125; work := &amp;Work&#123; config: self.config, signer: types.NewBoeSigner(self.config.ChainId), state: state, ancestors: set.New(), family: set.New(), uncles: set.New(), header: header, createdAt: time.Now(), &#125; // when 08 is processed ancestors contain 07 (quick block) for _, ancestor := range self.chain.GetBlocksFromHash(parent.Hash(), 7) &#123; for _, uncle := range ancestor.Uncles() &#123; work.family.Add(uncle.Hash()) &#125; work.family.Add(ancestor.Hash()) work.ancestors.Add(ancestor.Hash()) &#125; // Keep track of transactions which return errors so they can be removed work.tcount = 0 self.current = work return nil&#125;]]></content>
      <categories>
        <category>HPBÊ∫êÁ†ÅËß£ËØª</category>
      </categories>
      <tags>
        <tag>HPB</tag>
        <tag>Âå∫ÂùóÈìæ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GO-HPBÊ∫êÁ†ÅËß£ËØª--ÊåñÁüøÊµÅÁ®ãÔºà‰∫åÔºâ]]></title>
    <url>%2F2019%2F07%2F21%2FGO-HPB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%8C%96%E7%9F%BF%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ËøôÁ´†Êù•Áúã‰∏ãHPBÁöÑÊåñÁüøÊµÅÁ®ã„ÄÇÂú®ËäÇÁÇπÂêØÂä®ÁöÑÊó∂ÂÄôÈÄöËøáflagÂèÇÊï∞mineÊåáÂÆöÊòØÂê¶ËøõË°åÊåñÁüøÔºåÂΩìÁÑ∂‰πüÂèØ‰ª•Âú®ËäÇÁÇπÂêØÂä®ÂêéÈÄöËøáAPIÊù•Ë∞ÉÁî®ÔºåÂêØÂä®ÊµÅÁ®ã‰ª£Á†ÅË∞ÉÁî®È°∫Â∫èÊòØgo-hpb/cmd/ghpb/main.go-main-&gt;ghpb-&gt;startNode`„ÄÇÂú®startNodeÊñπÊ≥ïÊúÄÂêéÈÉ®ÁΩ≤‰ª£Á†ÅÂèØ‰ª•ÁúãÂà∞ÔºåÈ¶ñÂÖàÂà§Êñ≠MiningEnabledFlagÂíåRoleType‰∏§‰∏™ÂèÇÊï∞ÂêéÔºåËÆæÁΩÆ‰∫§ÊòìÁöÑGasPriceÂêéÔºàÁ≥ªÁªüÈªòËÆ§‰∏∫defaultGasPrice = 50 * config.ShannonÔºâÔºåÂºÄÂêØÊåñÁüø„ÄÇ 123456if ctx.GlobalBool(utils.MiningEnabledFlag.Name) &amp;&amp; (conf.Network.RoleType == "") &#123; stack.TxPool().SetGasPrice(utils.GlobalBig(ctx, utils.GasPriceFlag.Name)) if err := stack.StartMining(true); err != nil &#123; utils.Fatalf("Failed to start mining: %v", err) &#125; &#125; Âú®StartMiningÊñπÊ≥ï‰∏≠ ËÆæÁΩÆÊåñÁüøÂú∞ÂùÄcoinbaseÔºåËøô‰∏™Âú∞ÂùÄÊòØÂú®HpbConfigÂàùÂßãÂåñÁöÑÊó∂ÂÄôËÆæÁΩÆÁöÑÔºåÂèñÁöÑÊòØÈí±ÂåÖ‰∏≠Á¨¨‰∏Ä‰∏™Â∏êÊà∑Âú∞ÂùÄ Ëé∑ÊåñÁüøÂºïÊìéPrometheusÔºåÂπ∂ÊääcoinbaseÂíåÊâÄÂú®Èí±ÂåÖÁöÑÁ≠æÂêçÊñπÊ≥ï‰º†ÈÄíÁªôÂºïÊìé„ÄÇËøô‰∏™Êìç‰Ωú‰∏ªË¶ÅÊòØ‰∏∫‰∫Ü‰ªéwallet‰∏≠ÂèñÂá∫coinbaseÁöÑÁßÅÈí•ÔºåÁÑ∂ÂêéËøõË°åÊåñÁüøÁ≠æÂêç ÂºÄÂêØÊé•Êî∂‰∫§ÊòìÁöÑflag minerÂçèÁ®ãÂêØÂä®12345if wallets := hpbnode.AccountManager().Wallets(); len(wallets) &gt; 0 &#123; if account := wallets[0].Accounts(); len(account) &gt; 0 &#123; hpbnode.hpberbase = account[0].Address &#125; &#125; 123456789101112131415161718192021222324func (s *Node) StartMining(local bool) error &#123; //read coinbase from node eb := s.hpberbase if promeengine, ok := s.Hpbengine.(*prometheus.Prometheus); ok &#123; wallet, err := s.accman.Find(accounts.Account&#123;Address: eb&#125;) if wallet == nil || err != nil &#123; log.Error("Hpberbase account unavailable locally", "err", err) return fmt.Errorf("signer missing: %v", err) &#125; promeengine.Authorize(eb, wallet.SignHash) &#125; else &#123; log.Error("Cannot start mining without prometheus", "err", s.Hpbengine) &#125; if local &#123; // If local (CPU) mining is started, we can disable the transaction rejection // mechanism introduced to speed sync times. CPU mining on mainnet is ludicrous // so noone will ever hit this path, whereas marking sync done on CPU mining // will ensure that private networks work in single miner mode too. atomic.StoreUint32(&amp;s.Hpbsyncctr.AcceptTxs, 1) &#125; go s.miner.Start(eb) return nil&#125; Âú®StartÊñπÊ≥ï‰∏≠Ôºå ÊâßË°åminer.update()ÊñπÊ≥ï ËÆæÁΩÆÁä∂ÊÄÅ‰∏∫shouldStart==1ÔºåË°®Á§∫‰∏çÂÖÅËÆ∏ÂÜçÊ¨°ÊåñÁüø‰∫ÜÔºåÂõ†‰∏∫Â∑≤ÁªèÂºÄÂßã‰∫Ü„ÄÇ ËÆæÁΩÆÊåñÁüøÂú∞ÂùÄcoinbase Âà§Êñ≠ËÉΩÂê¶ËøõË°åÊåñÁüøÔºåÂ¶ÇÊûú‰∏çËÉΩÂàôËøîÂõûÔºå‰∏çÂêØÂä®ÊåñÁüø worker.start()ÂºÄ‰ΩøÁî®ÊåñÁüøÔºåworker.startNewMinerRound()Â∞ùËØïÂÜçÊ¨°ÂêØÂä®ÊåñÂ∑•worker123456789101112131415161718func (self *Miner) Start(coinbase common.Address) &#123; // go self.update() atomic.StoreInt32(&amp;self.shouldStart, 1) self.worker.setHpberbase(coinbase) self.coinbase = coinbase if atomic.LoadInt32(&amp;self.canStart) == 0 &#123; log.Info("Network syncing, will start miner afterwards") return &#125; atomic.StoreInt32(&amp;self.mining, 1) log.Info("Starting mining operation") self.worker.start() self.worker.startNewMinerRound()&#125; Âú®miner.update()ÊñπÊ≥ï‰∏≠Ôºåminer.muxËÆ¢ÈòÖ‰∫Ü‰∏â‰∏™‰∫ã‰ª∂ÔºåÂàÜÂà´ÊòØ‰∏ãËΩΩÂºÄÂßã‰∫ã‰ª∂Ôºå‰∏ãËΩΩÁªìÊùü‰∫ã‰ª∂Ôºå‰∏ãËΩΩÂ§±Ë¥•‰∫ã‰ª∂ÔºåËøô‰∏™Âíå‰ª•Â§™ÂùäÁöÑÊ∫êÁ†ÅÊúâ‰∫õ‰∏çÂêåÔºå‰ª•Â§™ÂùäÊòØdownloader.StartEvent{}, downloader.DoneEvent{}, downloader.FailedEvent{}Ôºå‰ΩúÁî®ÁöÑÊòØ‰∏ÄÊ†∑ÔºåÂú®HPBÊ∫êÁ†Å‰∏≠ÂèØ‰ª•Áúã‰∏ã‰∏â‰∏™‰∫ã‰ª∂ÁöÑÂèëÂá∫ÈÉΩÊòØÂíå‰ø°ÊÅØÂêåÊ≠•ÊúâÂÖ≥ÁöÑ,ÊØîÂ¶ÇÂú®synfast.go„ÄÅsynfull.go„ÄÅsynlight.go‰∏≠ÁöÑsyncWithPeerÊñπÊ≥ï‰∏≠ËøõË°å‰∫ã‰ª∂ÂèëÂ∏É Â¶ÇÊûúÊî∂Âà∞‰∏ãËΩΩÂºÄÂßã‰∫ã‰ª∂ÔºåÂàôÂÅúÊ≠¢ÂΩìÂâçÁöÑÊåñÁüøÂ∑•‰Ωú Â¶ÇÊü•Êî∂Âà∞‰∏ãËΩΩÂÆåÊàêÊàñÂ§±Ë¥•‰∫ã‰ª∂ÔºåÂàôÂºÄÂêØÊåñÁüøÂ∑•‰ΩúÔºåÂêåÊó∂ÂèñÊ∂à‰∫ã‰ª∂ËÆ¢ÈòÖÂèØ‰ª•ÁúãÂà∞update‰∏≠‰πüÊúâÂèØËÉΩÂêØÂä®ÊåñÁüøË°å‰∏∫ÁöÑÔºåÊâÄ‰ª•‰ΩøÁî®atomicÊù•ËøõË°åÁä∂ÊÄÅÁÆ°ÁêÜÔºåÂÆûÁé∞Á∫øÁ®ãÂÆâÂÖ®„ÄÇ 12345678910111213141516171819202122232425262728293031// update keeps track of the synctrl events. Please be aware that this is a one shot type of update loop.// It's entered once and as soon as `Done` or `Failed` has been broadcasted the events are unregistered and// the loop is exited. This to prevent a major security vuln where external parties can DOS you with blocks// and halt your mining operation for as long as the DOS continues.func (self *Miner) update() &#123; events := self.mux.Subscribe(synctrl.StartEvent&#123;&#125;, synctrl.DoneEvent&#123;&#125;, synctrl.FailedEvent&#123;&#125;)out: for ev := range events.Chan() &#123; switch ev.Data.(type) &#123; case synctrl.StartEvent: atomic.StoreInt32(&amp;self.canStart, 0) if self.Mining() &#123; self.Stop() atomic.StoreInt32(&amp;self.shouldStart, 1) log.Info("Mining aborted due to sync") &#125; case synctrl.DoneEvent, synctrl.FailedEvent: shouldStart := atomic.LoadInt32(&amp;self.shouldStart) == 1 atomic.StoreInt32(&amp;self.canStart, 1) atomic.StoreInt32(&amp;self.shouldStart, 0) if shouldStart &#123; self.Start(self.coinbase) &#125; // unsubscribe. we're only interested in this event once events.Unsubscribe() // stop immediately and ignore all further pending events break out &#125; &#125;&#125; Âú®worker.start()ÊñπÊ≥ï‰∏≠ÔºåÈ¶ñÂÖàËÆæÁΩÆ‰∫ÜworkerÁöÑÁä∂ÊÄÅÔºåÁÑ∂ÂêéÂÜçÂêØÂä®producer.Start()„ÄÇËøôÈáåproducerÊòØÊé•Âè£Á±ªÔºåÂÖ∂ÂÆûÁé∞Á±ªÂè™Êúâ‰∏Ä‰∏™ÔºåÊòØCpuAgent„ÄÇproducerÁªëÂÆöCpuAgentÊòØÈÄöËøáËøôË°å‰ª£Á†ÅËøõË°åÊ≥®ÂÜåÁöÑminer.Register(NewCpuAgent(bc.InstanceBlockChain(), engine))„ÄÇ‰ª£Á†ÅË∞ÉÁî®È°∫Â∫èÊòØ‚Äì&gt;ghpb‚Äì&gt;startNode‚Äì&gt;utils.StartNode(stack)‚Äì&gt;stack.Start(stack.Hpbconfig)‚Äì&gt;hpbnode.WorkerInit(conf)‚Äì&gt;hpbnode.miner = worker.New(&amp;conf.BlockChain, hpbnode.NewBlockMux(), hpbnode.Hpbengine, hpbnode.hpberbase)‚Äì&gt;miner.Register(NewCpuAgent(bc.InstanceBlockChain(), engine)) 1234567891011func (self *worker) start() &#123; self.mu.Lock() defer self.mu.Unlock() atomic.StoreInt32(&amp;self.mining, 1) // spin up agents for producer := range self.producers &#123; producer.Start() &#125;&#125; Êé•‰∏ãÊù•Áõ¥Êé•Áúã‰∏ãCpuAgent.Start()ÊñπÊ≥ï È¶ñÂÖàËøõË°åCASÁä∂ÊÄÅÂà§Êñ≠ ÂçèÁ®ãÂêØÂä®updateÊñπÊ≥ïÔºåËøô‰∏™Á±ª‰ºº‰∫éminerÁöÑupdateÊñπÊ≥ï 123456func (self *CpuAgent) Start() &#123; if !atomic.CompareAndSwapInt32(&amp;self.isMining, 0, 1) &#123; return // producer already started &#125; go self.update()&#125; updateÊñπÊ≥ï‰∏≠ÔºåÂú®Ê≠ªÂæ™ÁéØ‰∏≠‰∏çÊñ≠‰ªéchan‰∏≠Ëé∑ÂèñÊï∞ÊçÆÔºåÂ¶ÇÊûúÊï∞ÊçÆÁ±ªÂûãÊòØstopÔºåÂàôÈÄÄÂá∫Âæ™ÁéØÔºåÂ¶ÇÊûúÊòØworkChÂàôÂºÄÂßãÊåñÁüø„ÄÇstop‰∫ã‰ª∂ÊòØÂú®miner.updateÊñπÊ≥ï‰∏≠‰ºö‰º†ÈÄí„ÄÇworkÁöÑ‰º†ÈÄíÊòØÂú®miner.Start()ÊñπÊ≥ï‰∏≠startNewMinerRound()&lt;-makeCurrent()‰º†ÈÄíËøõÂéªÁöÑ„ÄÇ 123456789101112131415161718192021222324func (self *CpuAgent) update() &#123;out: for &#123; select &#123; case work := &lt;-self.workCh: self.mu.Lock() if self.quitCurrentOp != nil &#123; close(self.quitCurrentOp) &#125; self.quitCurrentOp = make(chan struct&#123;&#125;) go self.mine(work, self.quitCurrentOp) self.mu.Unlock() case &lt;-self.stop: self.mu.Lock() if self.quitCurrentOp != nil &#123; close(self.quitCurrentOp) self.quitCurrentOp = nil &#125; self.mu.Unlock() break out &#125; &#125;&#125; go self.mine(work, self.quitCurrentOp)ÊâçÂºÄÂßãÁúüÊ≠£ÁöÑÊåñÁüøËÆ°ÁÆóÔºåÔºå‰∏ã‰∏ÄÁ´†ËäÇÂÜçËØ¶ÁªÜÂàÜÊûê„ÄÇ]]></content>
      <categories>
        <category>HPBÊ∫êÁ†ÅËß£ËØª</category>
      </categories>
      <tags>
        <tag>HPB</tag>
        <tag>Âå∫ÂùóÈìæ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GO-HPBÊ∫êÁ†ÅËß£ËØª--ÊåñÁüøÊµÅÁ®ãÔºà‰∏ÄÔºâ]]></title>
    <url>%2F2019%2F07%2F21%2FGO-HPB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%8C%96%E7%9F%BF%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Âú®ÂºÄÊûêÊµÅÁ®ãÂâçÂÖàÁúã‰∏ã‰∏ªË¶ÅÁöÑÊï∞ÊçÆÁªìÊûÑÔºåÊåñÁüøÂ∑•‰Ωú‰∏ªË¶ÅÁî±‰∏â‰∏™ÂØπË±°Êù•ÂÆåÊàêÁöÑÔºåminer„ÄÅworker„ÄÅcpuAgentÔºåÂÖ∂‰∏≠cpuAgentÂÆûÁé∞ProducerÊé•Âè£Á±ª minerÊòØÂÖ•Âè£ÔºåË¥üË¥£‰∏éÂ§ñÈÉ®‰∫§‰∫íÔºåÊéßÂà∂ÊåñÁüøÊµÅÁ®ãÁöÑÂêØÂÅúÊìç‰Ωú workerÁÆ°ÁêÜWork‰ªªÂä°Ôºå‰ªñ‰ª£ÁêÜÁùÄProducerÊé•Âè£Á±ªÔºå‰πüÂ∞±ÊòØ‰ª£ÁêÜÁùÄÂÖ∑‰ΩìÊåñÁüøÊâßË°åÁùÄ cpuAgentË¥üË¥£ÂÖ∑‰ΩìÊåñÁüøËÆ°ÁÆóÂ∑•‰Ωú 1234567891011// Miner creates blocks and searches for proof-of-work values.type Miner struct &#123; mux *sub.TypeMux worker *worker coinbase common.Address mining int32 engine consensus.Engine canStart int32 // can start indicates whether we can start the mining operation shouldStart int32 // should start indicates whether we should start after sync&#125; Â≠óÊÆµ Á±ªÂûã Âê´‰πâ Â§áÊ≥® mux *sub.TypeMux Êé•Êî∂Êù•Ëá™ÂêåÊ≠•Ê®°ÂùóÁöÑStartEvent DoneEvent FailedEvent‰∫ã‰ª∂ÈÄöÁü•„ÄÇÂú®ÁΩëÁªú‰∏≠Ôºå‰∏çÂèØËÉΩÂè™Êúâ‰∏Ä‰∏™ÁüøÂ∑•ËäÇÁÇπ,ÂΩìËäÇÁÇπÂºÄÂßã‰ªéÂÖ∂‰ªñËäÇÁÇπÂêåÊ≠•BlockÊó∂ÔºåÊàë‰ª¨Â∞±Ê≤°ÊúâÂøÖË¶ÅÂÜçÁªßÁª≠ÊåñÁüø‰∫Ü worker *worker ÂÖ∑‰ΩìÊâßË°åÊåñÁüøÁöÑÂ∑•‰∫∫ coinbase common.Address ÊåñÁüøÂú∞ÂùÄÔºåÊåñÁüøÊâÄÂæóÁöÑÊî∂ÂÖ•Â∞ÜËÆ°ÂÖ•ËØ•Ë¥¶Êà∑ mining int32 ÊåñÁüøÁä∂ÊÄÅ engine consensus.Engine ÂÖ±ËØÜÂºïÊìé canStart int32 ÊòØÂê¶ÂèØ‰ª•ÂºÄÂßãÊåñÁüø shouldStart int32 quitCurrentOp 1234567891011121314151617181920212223242526272829303132// worker is the main object which takes care of applying messages to the new statetype worker struct &#123; config *config.ChainConfig engine consensus.Engine mu sync.Mutex // update loop mux *sub.TypeMux pool *txpool.TxPool txCh chan bc.TxPreEvent txSub sub.Subscription //txSub sub.Subscription chainHeadCh chan bc.ChainHeadEvent chainHeadSub sub.Subscription chainSideCh chan bc.ChainSideEvent chainSideSub sub.Subscription wg sync.WaitGroup producers map[Producer]struct&#123;&#125; recv chan *Result chain *bc.BlockChain proc bc.Validator chainDb hpbdb.Database coinbase common.Address extra []byte currentMu sync.Mutex current *Work uncleMu sync.Mutex possibleUncles map[common.Hash]*types.Block unconfirmed *unconfirmedBlocks // set of locally mined blocks pending canonicalness confirmations // atomic status counters mining int32 atWork int32&#125; Â≠óÊÆµ Á±ªÂûã Âê´‰πâ Â§áÊ≥® config *config.ChainConfig engine consensus.Engine mu sync.Mutex mux *sub.TypeMux Ê≥®ÊÑè‰∏éminer.muxÂ±ûÊÄß‰∏çÂêåÔºåËøôÈáåÊòØÂêëÂ§ñÈÉ®ÂèëÂ∏ÉÂ∑≤ÁªèÊåñÂà∞Êñ∞Block pool *txpool.TxPool txCh chan bc.TxPreEvent Êé•Êî∂txPool‰∏≠txÁöÑÈÄöÈÅì txSub sub.Subscription chainHeadCh chan bc.ChainHeadEvent Êé•Êî∂Âå∫ÂùóÂ§¥ÁöÑÈÄöÈÅì chainHeadSub sub.Subscription chainSideCh chan bc.ChainSideEvent Êé•Êî∂‰∏ªÂ§áÈìæÂèòÊõ¥ÈÄöÈÅì chainSideSub sub.Subscription wg sync.WaitGroup producers map[Producer]struct{} workerÊã•Êúâ‰∏Ä‰∏™ProducerÁöÑmapÈõÜÂêà recv chan *Result ProducerÁªìÊûúÂèëÈÄÅÈÄöÈÅìÔºåÊØè‰∏™ÁÆ°ÁêÜÁöÑProducerÈÉΩÂèØËÉΩÂ∞ÜÊåñÂá∫ÁöÑBlockÂèëÂà∞ËØ•Channel,‰πüÂ∞±ÊòØËØ¥,Ëøô‰∏™Êî∂ÊñπÂêëChannelÊòØ‰∏ÄÂØπÂ§öÁöÑ chain *bc.BlockChain proc bc.Validator chainDb hpbdb.Database Â≠òÂÇ®Êï∞ÊçÆÂ∫ì coinbase common.Address ÊåñÁüøÂú∞ÂùÄ extra []byte currentMu sync.Mutex current *Work uncleMu sync.Mutex possibleUncles map[common.Hash]*types.Block unconfirmed *unconfirmedBlocks Êú¨Âú∞ÊåñÂá∫ÁöÑÂæÖÁ°ÆËÆ§ÁöÑÂùó mining int32 atWork int32 1234567// Agent can register themself with the workertype Producer interface &#123; Work() chan&lt;- *Work SetReturnCh(chan&lt;- *Result) Stop() Start()&#125; ProducerÊòØ‰∏™Êé•Âè£Á±ªÔºå‰∏ªË¶ÅÂÆö‰πâ‰∫Ü‰∏Ä‰∫õÊìç‰ΩúÊñπÊ≥ïÔºåÂú®HPB‰∏≠ÔºåËØ•Êé•Âè£Á±ªÂè™ÊúâCpuAgentËøô‰∏Ä‰∏™ÂÆûÁé∞Á±ª 12345678910111213type CpuAgent struct &#123; mu sync.Mutex workCh chan *Work stop chan struct&#123;&#125; quitCurrentOp chan struct&#123;&#125; returnCh chan&lt;- *Result chain consensus.ChainReader engine consensus.Engine isMining int32 // Ê≠£Âú®ÊåñÁüø&#125; Â≠óÊÆµ Á±ªÂûã Âê´‰πâ Â§áÊ≥® mu sync.Mutex workCh chan *Work Êé•Êî∂Êù•Ëá™worker‰∏ãÂèëÁöÑÂ∑•‰Ωú‰ªªÂä°Work stop chan struct{} ‰ΩøËØ•CpuAgentÂÅúÊ≠¢Â∑•‰ΩúÁöÑ‰ø°Âè∑ quitCurrentOp chan struct{} ÈÄÄÂá∫ÂΩìÂâçÊìç‰ΩúÈÄöÈÅì returnCh chan&lt;- *Result ÂêëworkerÂèçÈ¶àÂ∑•‰Ωú‰ªªÂä°ÁöÑÂÆåÊàêÊÉÖÂÜµ,ÂÆûÈôÖ‰∏äÂ∞±ÊòØÊåñÂá∫ÁöÑÊñ∞Block chain consensus.ChainReader Áî®‰∫éËÆøÈóÆÊú¨Âú∞ËäÇÁÇπBlockChainÊï∞ÊçÆÁöÑÊé•Âè£ engine consensus.Engine ËÆ°ÁÆóÊâÄÈááÁî®ÁöÑÂÖ±ËØÜÂºïÊìé isMining int32 ÊòØÂê¶Ê≠£Âú®ÊåñÁüø]]></content>
      <categories>
        <category>HPBÊ∫êÁ†ÅËß£ËØª</category>
      </categories>
      <tags>
        <tag>HPB</tag>
        <tag>Âå∫ÂùóÈìæ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GO-HPBÊ∫êÁ†ÅËß£ËØª--LevelDBÊìç‰Ωú]]></title>
    <url>%2F2019%2F07%2F21%2FGO-HPB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-LevelDB%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[HPB‰ΩøÁî®LevelDBÂ≠òÂÇ®Êï∞ÊçÆ„ÄÇgo-hpb/blockchain/database_util.goÊñá‰ª∂Â∞ÅË£Ö‰∫ÜLevelDBÁöÑÊìç‰Ωú„ÄÇÂõ†‰∏∫LevelDBÊòØ&lt;k, v&gt;Êï∞ÊçÆÂ∫ìÔºåÊâÄ‰ª•ÊâÄÊúâÊï∞ÊçÆÁöÑÂ≠òÂÇ®ÈÉΩÈúÄË¶ÅÊåáÂÆök„ÄÇ‰ª•‰∏ã‰ª£Á†ÅÂàóÂá∫‰∫ÜÊâÄÊúâÈúÄË¶Å‰øùÂ≠òÁöÑÊï∞ÊçÆÁöÑkÊàñËÄÖkÁöÑÂâçÁºÄ„ÄÇ ¬∑¬∑¬∑ voteResultKey = []byte(‚Äúvote-result-key‚Äù) headHeaderKey = []byte(&quot;LastHeader&quot;) headBlockKey = []byte(&quot;LastBlock&quot;) headFastKey = []byte(&quot;LastFast&quot;) // Data item prefixes (use single byte to avoid mixing data types, avoid `i`). headerPrefix = []byte(&quot;h&quot;) // headerPrefix + num (uint64 big endian) + hash -&gt; header tdSuffix = []byte(&quot;t&quot;) // headerPrefix + num (uint64 big endian) + hash + tdSuffix -&gt; td numSuffix = []byte(&quot;n&quot;) // headerPrefix + num (uint64 big endian) + numSuffix -&gt; hash blockHashPrefix = []byte(&quot;H&quot;) // blockHashPrefix + hash -&gt; num (uint64 big endian) bodyPrefix = []byte(&quot;b&quot;) // bodyPrefix + num (uint64 big endian) + hash -&gt; block body blockReceiptsPrefix = []byte(&quot;r&quot;) // blockReceiptsPrefix + num (uint64 big endian) + hash -&gt; block receipts lookupPrefix = []byte(&quot;l&quot;) // lookupPrefix + hash -&gt; transaction/receipt lookup metadata bloomBitsPrefix = []byte(&quot;B&quot;) // bloomBitsPrefix + bit (uint16 big endian) + section (uint64 big endian) + hash -&gt; bloom bits randomPrefix = []byte(&quot;random&quot;) // randomPrefix + num (uint64 big endian) + hash -&gt; header preimagePrefix = &quot;secure-key-&quot; // preimagePrefix + hash -&gt; preimage configPrefix = []byte(&quot;hpb-config-&quot;) // config prefix for the db BloomBitsIndexPrefix = []byte(&quot;iB&quot;) // BloomBitsIndexPrefix is the data table of a chain indexer to track its progress oldReceiptsPrefix = []byte(&quot;receipts-&quot;) oldTxMetaSuffix = []byte{0x01} ËøôÈáåÂØπ‰∏ªË¶ÅÊï∞ÊçÆÁöÑkÂâçÁºÄÊï¥ÁêÜ‰∏ã,ÂÖ∂‰∏≠hashÊåáÁöÑÊòØÂå∫ÂùóÁöÑhashÔºåÁ≠â‰∫éheader‰∏≠ÁöÑhashÔºå‰ª£Á†Å‰∏≠Áß∞canonical hash„ÄÇnumÊòØÊåáÂå∫ÂùóÁöÑÈ´òÂ∫¶ÊàñËÄÖ‰ΩçÁΩÆÔºåË°®Á§∫Á¨¨Âá†‰∏™Âå∫Âùó key|Value -|- h+num+hash|header h+num+hash+t|tdh+num+n |hashH+hash | numb+num+hash |block bodyr+num+hash |block receiptsl+hash | transaction/receipt lookup metadataB+bit+section+hash |bloom bits database_util.goÊñá‰ª∂Â§ßÈÉ®ÂàÜÂÜÖÂÆπÊòØwriteÂíågetÊñπÊ≥ïÔºå‰ª•ÂâçÂØπÂâçÁºÄÁöÑÊãºÊé• ‰ª•‰∏ãÂÜÖÂÆπËΩ¨Ëá™ÁΩëÁªúÔºå‰Ωú‰∏™Â§áÊ≥® StateObject: ÊòØ‰∏Ä‰∏™Ë¥¶Âè∑(Âú∞ÂùÄ)ÁöÑÁä∂ÊÄÅ‰ø°ÊÅØ ÂØπ‰∫éÊôÆÈÄöË¥¶Âè∑ÔºåËøô‰∏™ÂØπË±°‰øùÂ≠ò‰∫Übalance, nonceÁ≠â‰ø°ÊÅØ ÂØπ‰∫éÊô∫ËÉΩÂêàÁ∫¶Ë¥¶Âè∑ÔºåËøòÈ¢ùÂ§ñ‰øùÁïô‰∫ÜÊô∫ËÉΩÂêàÁ∫¶ÁöÑÁä∂ÊÄÅÔºåËøô‰∏™Áä∂ÊÄÅÂ∞±ÊòØÊô∫ËÉΩÂêàÁ∫¶ÈáåÁöÑÂÆö‰πâÁöÑÂêÑÁßçÂèòÈáèÁöÑÂÄº„ÄÇ‰ª•Â§™ÂùäËôöÊãüÊú∫ÁöÑÂèòÈáèÊòØ‰ª•&lt;k, v&gt;Â≠òÂÇ®ÁöÑÔºåÊâÄ‰ª•Ëøô‰∏™Áä∂ÊÄÅÂ∞±ÊòØÂ§ßÈáè&lt;k, v&gt;ÂØπË±°„ÄÇ]]></content>
      <categories>
        <category>HPBÊ∫êÁ†ÅËß£ËØª</category>
      </categories>
      <tags>
        <tag>HPB</tag>
        <tag>Âå∫ÂùóÈìæ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GO-HPBÊ∫êÁ†ÅËß£ËØª--Â§öÂ∏êÂè∑Ëß£ÈîÅ]]></title>
    <url>%2F2019%2F07%2F21%2FGO-HPB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E5%A4%9A%E5%B8%90%E5%8F%B7%E8%A7%A3%E9%94%81%2F</url>
    <content type="text"><![CDATA[Âú®ÂêØÂä®ËäÇÁÇπÊó∂ÔºåËß£ÈîÅÂèÇÊï∞ÂèØ‰ª•ÂêåÊó∂ÊåáÂÆöÂ§ö‰∏™Â∏êÂè∑ÔºåÊ†ºÂºè‰∏∫--unlock &quot;addr1,addr2,addr3...&quot; --password &quot;pwd&quot;,ÂÖ∂‰∏≠unlockÂèÇÊï∞‰∏∫Â§ö‰∏™Â∏êÂè∑ÁöÑÂú∞ÂùÄÔºåÁî®ÈÄóÂè∑ÂàÜÈöîÔºõpasswordÂèÇÊï∞‰∏∫Âè£‰ª§Êñá‰ª∂ÔºåÊñá‰ª∂‰∏≠ÁöÑÂè£‰ª§ÊØèË°å‰∏Ä‰∏™Âè£‰ª§„ÄÇÂú®ÂàõÂª∫Â∏êÂè∑Êó∂ÔºåÂëΩ‰ª§./ghpb --datadir node/data account initÂèØ‰ª•Â§öÊ¨°ÊâßË°åÔºåÊØèÊ¨°ÊâßË°åÂêéÔºå‰ºöÂú®Ë∑ØÂæÑnode/data/keystore‰∏ãÁîüÊàêÂ§ö‰∏™Â∏êÂè∑Êñá‰ª∂ÔºåÊØîÂ¶ÇUTC‚Äì2018-11-29T08-21-25.565157387Z‚Äì3e8aadb68222c70b309e87cd5c27e97950879076„ÄÇÂΩìËäÇÁÇπÂêØÂä®ÊåáÂÆöÂ§ö‰∏™Â∏êÂè∑Êó∂Ôºå‰ºöÂä†ËΩΩÂØπÂ∫îÁöÑÂ∏êÂè∑Êñá‰ª∂ÔºåÂπ∂Ëß£ÈîÅ„ÄÇ‰∏ãËæπÁúã‰∏Ä‰∏ãËß£ÈîÅÁöÑ‰ª£Á†Å„ÄÇ ÂêØÂä®ËäÇÁÇπÂÖ•Âè£main.goÁöÑinitÊñπÊ≥ïÔºåË∞ÉÁî®ËøáÁ®ã‰∏∫init()‚Äì&gt;ghpb‚Äì&gt;startNode() 1234567func init() &#123; // Initialize the CLI app and start Geth app.Action = ghpb app.HideVersion = true // we have a command to print the version app.Copyright = "Copyright 2013-2018 The go-hpb Authors " app.Commands = []cli.Command&#123; ...ÁúÅÁï•... 1234567891011121314// ghpb is the main entry point into the system if no special subcommand is ran.// It creates a default node based on the command line arguments and runs it in// blocking mode, waiting for it to be shut down.func ghpb(ctx *cli.Context) error &#123; cfg := MakeConfigNode(ctx) hpbnode, err := createNode(cfg) if err != nil &#123; utils.Fatalf("Failed to create node") return err &#125; startNode(ctx, hpbnode, cfg) hpbnode.Wait() return nil&#125; Âú®startNodeÊñπÊ≥ï‰∏≠ È¶ñÂÖàËé∑ÂèñkeyStoreÁöÑÊåáÈíà MakePasswordListÊñπÊ≥ïËß£Êûê‚ÄìpasswordÂèÇÊï∞ÊåáÂÆöÁöÑÂè£‰ª§Êñá‰ª∂ÔºåÊñá‰ª∂‰∏≠ÁöÑÂÜÖÂÆπÊØè‰∏ÄË°åÂØπÂ∫î‰∏Ä‰∏™Âè£‰ª§ Ëé∑ÂèñÂ∏êÂè∑ÂàóË°®ÔºåËøõË°åÈÅçÂéÜËß£ÈîÅ ÂêéËæπÊòØÂêØÂä®ËäÇÁÇπÔºåÂπ∂ÂêØÂä®‰∏Ä‰∏™ÂçèÁ®ãÔºåÂºÄÂêØÈí±ÂåÖ‰∫ã‰ª∂ÁõëÂê¨„ÄÇËøôÈÉ®ÂàÜÂÜÖÂÆπÂêéÁª≠Á´†ËäÇ‰∏≠ÂÜçËøõË°åËß£ËØª„ÄÇ‰∏ãËæπÁúã‰∏ãÈÅçÂéÜÊó∂ÔºåÊØè‰∏™Â∏êÂè∑ÊòØÊÄé‰πà‰ΩøÁî®Âè£‰ª§Ëß£ÈîÅÁöÑ„ÄÇ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// startNode boots up the system node and all registered protocols, after which// it unlocks any requested accounts, and starts the RPC/IPC interfaces and the// miner.func startNode(ctx *cli.Context, stack *node.Node, conf *config.HpbConfig) &#123; // Unlock any account specifically requested ks := stack.AccountManager().KeyStore().(*keystore.KeyStore) passwords := utils.MakePasswordList(ctx) unlocks := strings.Split(ctx.GlobalString(utils.UnlockedAccountFlag.Name), ",") for i, account := range unlocks &#123; if trimmed := strings.TrimSpace(account); trimmed != "" &#123; unlockAccount(ctx, ks, trimmed, i, passwords) &#125; &#125; if unlocks[0] != "" &#123; account, err := utils.MakeAddress(ks, strings.TrimSpace(unlocks[0])) if err != nil &#123; utils.Fatalf("Could not list accounts: %v", err) &#125; conf.Node.DefaultAddress = account.Address &#125; //set rpc aii //utils.SetNodeAPI(&amp;conf.Node, stack) // Start up the node itself utils.StartNode(stack) // Register wallet event handlers to open and auto-derive wallets events := make(chan accounts.WalletEvent, 16) stack.AccountManager().Subscribe(events) go func() &#123; // Open any wallets already attached for _, wallet := range stack.AccountManager().Wallets() &#123; if err := wallet.Open(""); err != nil &#123; log.Warn("Failed to open wallet", "url", wallet.URL(), "err", err) &#125; &#125; // Listen for wallet event till termination for event := range events &#123; switch event.Kind &#123; case accounts.WalletArrived: if err := event.Wallet.Open(""); err != nil &#123; log.Warn("New wallet appeared, failed to open", "url", event.Wallet.URL(), "err", err) &#125; case accounts.WalletOpened: status, _ := event.Wallet.Status() log.Info("New wallet appeared", "url", event.Wallet.URL(), "status", status) case accounts.WalletDropped: log.Info("Old wallet dropped", "url", event.Wallet.URL()) event.Wallet.Close() &#125; &#125; &#125;() // Start auxiliary services if enabled if ctx.GlobalBool(utils.MiningEnabledFlag.Name) &amp;&amp; (conf.Network.RoleType == "") &#123; // Set the gas price to the limits from the CLI and start mining stack.TxPool().SetGasPrice(utils.GlobalBig(ctx, utils.GasPriceFlag.Name)) if err := stack.StartMining(true); err != nil &#123; utils.Fatalf("Failed to start mining: %v", err) &#125; &#125;&#125; Âú®unlockAccountÊñπÊ≥ï‰∏≠ÔºåÊØè‰∏™Â∏êÂè∑‰ºöËøõË°åÂ∞ùËØï3Ê¨°Ëß£ÈîÅ„ÄÇÊØèÊ¨°‰ºö‰ªéÂè£‰ª§ÂàóË°®‰∏≠ÂèñÂá∫‰∏Ä‰∏™Âè£‰ª§ËøõË°åËß£ÈîÅÂ∏êÂè∑ÔºåÂ¶ÇÊûúËß£ÈîÅÊàêÂäüÂàôËøîÂõûÔºåÂ§±Ë¥•ÂàôÁªßÁª≠„ÄÇÊñπÊ≥ïgetPassPhraseÊØèÊ¨°‰ªé‰ºóÂ§öÂè£‰ª§‰∏≠Âèñ‰∏Ä‰∏™Âè£‰ª§ÁöÑÊñπÂºèÊòØ‰ª•‰∏ãÈÉ®ÂàÜ‰ª£Á†ÅÂÆûÁé∞ÁöÑ ÔºåÂ¶ÇÊûúÂè£‰ª§‰∏™Êï∞Â§ß‰∫é3‰∏™ÁöÑËØùÔºåÂàôÊØèÊ¨°ÈÉΩ‰ºöÂèñÊúÄÂêé‰∏Ä‰∏™„ÄÇ‰∏çÊòØÂæàÁêÜËß£‰∏∫‰ΩïË¶ÅËøôÊ†∑ÂÅöÔºåÊåâÁêÜËØ¥Â∫îËØ•ÊØè‰∏™Â∏êÂè∑ÂØπÂ∫î‰∏Ä‰∏™Âè£‰ª§ÁöÑ„ÄÇüòÇüòÇüòÇ 123456if len(passwords) &gt; 0 &#123; if i &lt; len(passwords) &#123; return passwords[i] &#125; return passwords[len(passwords)-1] &#125;]]></content>
      <categories>
        <category>HPBÊ∫êÁ†ÅËß£ËØª</category>
      </categories>
      <tags>
        <tag>HPB</tag>
        <tag>Âå∫ÂùóÈìæ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GO-HPBÊ∫êÁ†ÅËß£ËØª--Êï∞ÊçÆÁªìÊûÑ]]></title>
    <url>%2F2019%2F07%2F21%2FGO-HPB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Âå∫ÂùóÈìæÊú¨Ë∫´Â∞±ÊòØÈÄöËøáÁâπÂÆöÁöÑÊú∫Âà∂Êù•ÁîüÊàêÂíåÁª¥Êä§Êï∞ÊçÆÔºå‰ΩøÊï∞ÊçÆÂÖ∑ÊúâÊûÅÈ´òÁöÑÁ®≥ÂÆöÊÄßÂíåÂèØÈù†ÊÄß„ÄÇÊâÄ‰ª•‰∫ÜËß£Âå∫ÂùóÈìæÔºåÈ¶ñÂÖàË¶ÅÂøÖÈ°ªÁÜüÊÇâÂÖ∂Êï∞ÊçÆÁªìÊûÑÔºåÁÑ∂ÂêéÊâçËÉΩÊõ¥Â•ΩÁöÑÁêÜËß£Êï∞ÊçÆËøêÁÆóÊú∫Âà∂‰πüÂ∞±ÊòØÂå∫ÂùóÈìæÁöÑËøêË°åÂéüÁêÜ„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// BlockChain represents the canonical chain given a database with a genesis// block. The Blockchain manages chain imports, reverts, chain reorganisations.//// Importing blocks in to the block chain happens according to the set of rules// defined by the two stage Validator. Processing of blocks is done using the// Processor which processes the included transaction. The validation of the state// is done in the second part of the Validator. Failing results in aborting of// the import.//// The BlockChain also helps in returning blocks from **any** chain included// in the database as well as blocks that represents the canonical chain. It's// important to note that GetBlock can return any block and does not need to be// included in the canonical one where as GetBlockByNumber always represents the// canonical chain.&lt;!-- more --&gt;type BlockChain struct &#123; config *config.ChainConfig // chain &amp; network configuration hc *HeaderChain chainDb hpbdb.Database rmLogsFeed sub.Feed chainFeed sub.Feed chainSideFeed sub.Feed chainHeadFeed sub.Feed logsFeed sub.Feed scope sub.SubscriptionScope genesisBlock *types.Block mu sync.RWMutex // global mutex for locking chain operations chainmu sync.RWMutex // blockchain insertion lock procmu sync.RWMutex // block processor lock checkpoint int // checkpoint counts towards the new checkpoint currentBlock *types.Block // Current head of the block chain currentFastBlock *types.Block // Current head of the fast-sync chain (may be above the block chain!) stateCache state.Database // State database to reuse between imports (contains state cache) bodyCache *lru.Cache // Cache for the most recent block bodies bodyRLPCache *lru.Cache // Cache for the most recent block bodies in RLP encoded format blockCache *lru.Cache // Cache for the most recent entire blocks futureBlocks *lru.Cache // future blocks are blocks added for later processing quit chan struct&#123;&#125; // blockchain quit channel running int32 // running must be called atomically // procInterrupt must be atomically called procInterrupt int32 // interrupt signaler for block processing wg sync.WaitGroup // chain processing wait group for shutting down engine consensus.Engine processor Processor // block processor interface validator Validator // block and state validator interface badBlocks *lru.Cache // Bad block cache&#125; Â≠óÊÆµ Á±ªÂûã Âê´‰πâ Â§áÊ≥® config *config.ChainConfig ÂÆö‰πâ‰∫ÜchainIDÂíåÁõëÊéßÂèÇÊï∞ hc *HeaderChain Âå∫ÂùóÂ§¥ÁªÑÊàêÁöÑÈìæ chainDb hpbdb.Database Êï∞ÊçÆÂ∫ì rmLogsFeed sub.Feed chainFeed sub.Feed chainSideFeed sub.Feed chainHeadFeed sub.Feed logsFeed sub.Feed scope sub.SubscriptionScope genesisBlock *types.Block mu sync.RWMutex Âå∫ÂùóÈìæÁöÑÂÖ®Â±ÄÈîÅ chainmu sync.RWMutex Âå∫ÂùóÈìæÊèíÂÖ•ÈîÅ procmu sync.RWMutex Âå∫ÂùóÂ§ÑÁêÜÁöÑÈîÅ checkpoint int currentBlock *types.Block ‰∏ªÈìæÁöÑÂ§¥Âå∫Âùó currentFastBlock *types.Block Âø´ÈÄüÂêåÊ≠•Ê®°Âºè‰∏ãÈìæÁöÑÂ§¥Âå∫ÂùóÔºåËøôÁßçÊÉÖÂÜµ‰∏ãÂèØËÉΩÊØî‰∏ªÈìæÈïø stateCache state.Database bodyCache *lru.Cache ÊúÄËøëÂå∫Âùó‰ΩìÁöÑÁºìÂ≠ò‰ø°ÊÅØ bodyRLPCache *lru.Cache ÊúÄËøëÂå∫Âùó‰ΩìÁöÑRLPÊ†ºÂºèÁöÑÁºìÂ≠ò‰ø°ÊÅØ blockCache *lru.Cache ÊúÄËøëÂå∫ÂùóÁöÑÁºìÂ≠ò futureBlocks *lru.Cache Â∞ÜÊù•Á≠âÂæÖ‰∏äÈìæÁöÑÂå∫Âùó quit chan struct{} running int32 procInterrupt int32 wg sync.WaitGroup engine consensus.Engine È™åËØÅÂå∫ÂùóÁöÑÂºïÊìé processor Processor ÊâßË°åÂå∫Âùó‰∫§ÊòìÁöÑÊé•Âè£ validator Validator È™åËØÅÂå∫ÂùóÂíåstateÊúâÊïàÊÄßÁöÑÊé•Âè£ badBlocks *lru.Cache È™åËØÅÂ§±Ë¥•ÁöÑÂå∫ÂùóÁºìÂ≠òÔºåÊù•Ëá™DAO‰∫ã‰ª∂ ÂÖ≥ÈîÆÁöÑÂÖÉÁ¥†Ôºö dbÔºöËøûÊé•Âà∞Â∫ïÂ±ÇÊï∞ÊçÆÂÇ®Â≠òÔºåÂç≥leveldbÔºõ hcÔºöheaderchainÂå∫ÂùóÂ§¥ÈìæÔºåÁî±blockchainÈ¢ùÂ§ñÁª¥Êä§ÁöÑÂè¶‰∏ÄÊù°ÈìæÔºåÁî±‰∫éHeaderÂíåBlockÁöÑÂÇ®Â≠òÁ©∫Èó¥ÊòØÊúâÂæàÂ§ßÂ∑ÆÂà´ÁöÑÔºå‰ΩÜÂêåÊó∂BlockÁöÑHashÂÄºÂ∞±ÊòØHeaderÔºàRLPÔºâÁöÑHashÂÄºÔºåÊâÄ‰ª•Áª¥Êä§‰∏Ä‰∏™headerchainÂèØ‰ª•Áî®‰∫éÂø´ÈÄüÂª∂ÈïøÈìæÔºåÈ™åËØÅÈÄöËøáÂêéÂÜç‰∏ãËΩΩblockchainÔºåÊàñËÄÖÂèØ‰ª•‰∏éblockchainËøõË°åÁõ∏‰∫íÈ™åËØÅÔºõ genesisBlockÔºöÂàõÂßãÂå∫ÂùóÔºõ currentBlockÔºöÂΩìÂâçÂå∫ÂùóÔºåblockchain‰∏≠Âπ∂‰∏çÊòØÂÇ®Â≠òÈìæÊâÄÊúâÁöÑblockÔºåËÄåÊòØÈÄöËøácurrentBlockÂêëÂâçÂõûÊ∫ØÁõ¥Âà∞genesisBlockÔºåËøôÊ†∑Â∞±ÊûÑÊàê‰∫ÜÂå∫ÂùóÈìæ„ÄÇ bodyCache„ÄÅbodyRLPCache„ÄÅblockCache„ÄÅfutureBlocksÔºöÂå∫ÂùóÈìæ‰∏≠ÁöÑÁºìÂ≠òÁªìÊûÑÔºåÁî®‰∫éÂä†Âø´Âå∫ÂùóÈìæÁöÑËØªÂèñÂíåÊûÑÂª∫Ôºõ engineÔºöÊòØconsensusÊ®°Âùó‰∏≠ÁöÑÊé•Âè£ÔºåÁî®Êù•È™åËØÅblockÁöÑÊé•Âè£Ôºõ processorÔºöÊâßË°åÂå∫ÂùóÈìæ‰∫§ÊòìÁöÑÊé•Âè£ÔºåÊî∂Âà∞‰∏Ä‰∏™Êñ∞ÁöÑÂå∫ÂùóÊó∂ÔºåË¶ÅÂØπÂå∫Âùó‰∏≠ÁöÑÊâÄÊúâ‰∫§ÊòìÊâßË°å‰∏ÄÈÅçÔºå‰∏ÄÊñπÈù¢ÊòØÈ™åËØÅÔºå‰∏ÄÊñπÈù¢ÊòØÊõ¥Êñ∞worldStateÔºõ validatorÔºöÈ™åËØÅÊï∞ÊçÆÊúâÊïàÊÄßÁöÑÊé•Âè£ futureBlocksÔºöÊî∂Âà∞ÁöÑÂå∫ÂùóÊó∂Èó¥Â§ß‰∫éÂΩìÂâçÂ§¥Âå∫ÂùóÊó∂Èó¥15sËÄåÂ∞è‰∫é30sÁöÑÂå∫ÂùóÔºåÂèØ‰Ωú‰∏∫ÂΩìÂâçËäÇÁÇπÂæÖÂ§ÑÁêÜÁöÑÂå∫Âùó„ÄÇ ‰∏ãËæπÊòØÂå∫ÂùóÁöÑÊï∞ÊçÆÁªìÊûÑ 12345678910111213141516171819// Block represents an entire block in the Hpb blockchain.type Block struct &#123; header *Header uncles []*Header transactions Transactions // caches hash atomic.Value size atomic.Value // Td is used by package core to store the total difficulty // of the chain up to and including the block. td *big.Int // These fields are used by package eth to track // inter-peer block relay. ReceivedAt time.Time ReceivedFrom interface&#123;&#125;&#125; Â≠óÊÆµ Á±ªÂûã Âê´‰πâ Â§áÊ≥® header *Header ÂΩìÂâçÂå∫ÂùóÂ§¥ uncles []*Header ÂèîÂå∫ÂùóÔºåÂõ†Âá∫ÂùóÈÄüÂ∫¶Âø´ÔºåÂØºËá¥ÂàÜÂèâÊ¶ÇÁéáÈ´òÔºå‰∏∫‰∫ÜÂ¢ûÂä†ÁüøÂ∑•ÊåñÁüøÁßØÊûÅÊÄßÔºåÂØπ‰∫éÂàÜÂèâÂêéÁöÑÊó†Áî®Âå∫Âùó‰πüËøõË°åÊâìÂåÖÔºåÂ•ñÂä±ÁüøÂ∑•ÔºåÈÇ£‰πàËøô‰∫õÊó†Áî®Âå∫ÂùóÂ∞±ÊòØÂèîÂå∫Âùó„ÄÇÂêåÊó∂‰∏∫‰∫Ü‰∏∫‰∫ÜÊäµÊ∂àÊï¥‰∏™EthereumÁΩëÁªú‰∏≠ÈÇ£‰∫õËÆ°ÁÆóËÉΩÂäõÁâπÂà´Âº∫Â§ßÁöÑËäÇÁÇπ‰ºöÂØπÂå∫ÂùóÁöÑ‰∫ßÁîüÊúâËøáÂ§ßÁöÑÂΩ±ÂìçÂäõÔºåÈò≤Ê≠¢Ëøô‰∫õËäÇÁÇπÁ†¥Âùè‚ÄúÂéª‰∏≠ÂøÉÂåñ‚ÄùËøô‰∏™Ê†πÊú¨ÂÆóÊó® transactions Transactions ‰∫§ÊòìÈõÜÂêà hash atomic.Value Âå∫ÂùóÁöÑÂìàÂ∏åÔºåÊòØ‰ªéHeader‰∏≠ÁºìÂ≠ò‰∏ãÊù•ÁöÑÔºåÁ≠â‰∫éHeader‰∏≠ÁöÑÂìàÂ∏åÂÄºÔºåÊòØheader‰∏≠Èô§nonceÂíåmixDigestÊï∞ÊçÆÂ§ñÁöÑrlpÁöÑhashÔºåËøôÊ†∑Áõ∏ÂêåÁöÑ‰∫§ÊòìÂÜÖÂÆπÁöÑÁõ∏ÂêåËØ•Âå∫ÂùóhashÊòØ‰∏ÄÊ†∑ÔºåÂì™ÊÄïÊòØÁî±‰∏çÂêåÁöÑËäÇÁÇπÂàõÂª∫Âá∫Êù•ÁöÑ„ÄÇÂå∫ÂùóÁöÑheaderÂíåbodyÊòØÂàÜÂºÄÂ≠òÂÇ®ÁöÑÔºåkeyÈÉΩÊòØÂâçÁºÄÂä†‰∏äÂΩìÂâçhash size atomic.Value td *big.Int tdÊòØtotalDifficultyÁöÑÁº©ÂÜôÔºåË°®Á§∫‰ªéÂàõ‰∏ñÂå∫ÂùóÂà∞ÂΩìÂâçÂå∫ÂùóÁöÑÊâÄÊúâDifficulty‰πãÂíåÔºåËÄåÊØè‰∏™Âå∫ÂùóÁöÑDifficultyÊòØ‰øùÂ≠òÂú®header‰∏≠ÁöÑ ReceivedAt time.Time Âå∫ÂùóÁîüÊàêÊó∂Èó¥ ReceivedFrom interface{} Âå∫ÂùóÁîüÊàêÊù•Ê∫ê 12345678910111213141516171819202122// Header represents a block header in the Hpb blockchain.type Header struct &#123; ParentHash common.Hash `json:"parentHash" ` UncleHash common.Hash `json:"sha3Uncles" ` Coinbase common.Address `json:"miner" ` CandAddress common.Address `json:"candAddress" ` ComdAddress common.Address `json:"comdAddress" ` VoteIndex *big.Int `json:"voteIndex" ` Root common.Hash `json:"stateRoot" ` TxHash common.Hash `json:"transactionsRoot" ` ReceiptHash common.Hash `json:"receiptsRoot" ` Bloom Bloom `json:"logsBloom" ` Difficulty *big.Int `json:"difficulty" ` Number *big.Int `json:"number" ` GasLimit *big.Int `json:"gasLimit" ` GasUsed *big.Int `json:"gasUsed" ` Time *big.Int `json:"timestamp" ` Extra []byte `json:"extraData" ` MixDigest common.Hash `json:"mixHash" ` Nonce BlockNonce `json:"nonce" ` HardwareRandom []byte `json:"hardwareRandom" `&#125; Â≠óÊÆµ Á±ªÂûã Âê´‰πâ Â§áÊ≥® ParentHash common.Hash Áà∂Âå∫ÂùóÁöÑhash UncleHash common.Hash ÂèîÂå∫ÂùóÁöÑhash Coinbase common.Address ÊåñÁüøÁîüÊàêËØ•Âå∫ÂùóÁöÑÂú∞ÂùÄÔºåÊåñÁüøÊòØÁî±ËäÇÁÇπÊù•ÂÆåÊàêÁöÑÔºåÊØè‰∏™fullËäÇÁÇπÈÉΩ‰∏™ÈªòËÆ§ÁöÑCoinbaseÂú∞ÂùÄÔºåÁî®Êù•Êé•Êî∂ÊåñÁüøÔºàÁüøÂ∑•Ë¥πÂíåÊâìÂåÖÂå∫ÂùóÁöÑÂ•ñÈáëÔºâÂ•ñÂä± CandAddress common.Address Ôºü ComdAddress common.Address Ôºü VoteIndex *big.Int ÊäïÁ•®Á¥¢Âºï Root common.Hash Â≠òÂÇ®Ë¥¶Êà∑ÔºàÂêàÁ∫¶Â∏êÊà∑ÂíåÁî®Êà∑Â∏êÊà∑ÔºâÁä∂ÊÄÅÁöÑMerkleÊ†ëÁöÑÊ†πËäÇÁÇπÁöÑÂìàÂ∏å,StateDB‰∏≠ÁöÑ‚Äústate Trie‚ÄùÁöÑÊ†πËäÇÁÇπÁöÑRLPÂìàÂ∏åÂÄº„ÄÇBlock‰∏≠ÔºåÊØè‰∏™Ë¥¶Êà∑‰ª•stateObjectÂØπË±°Ë°®Á§∫ÔºåË¥¶Êà∑‰ª•Address‰∏∫ÂîØ‰∏ÄÊ†áÁ§∫ÔºåÂÖ∂‰ø°ÊÅØÂú®Áõ∏ÂÖ≥‰∫§Êòì(Transaction)ÁöÑÊâßË°å‰∏≠Ë¢´‰øÆÊîπ„ÄÇÊâÄÊúâË¥¶Êà∑ÂØπË±°ÂèØ‰ª•ÈÄê‰∏™ÊèíÂÖ•‰∏Ä‰∏™Merkle-PatricaTrie(MPT)ÁªìÊûÑÈáåÔºåÂΩ¢Êàê‚Äústate Trie‚Äù„ÄÇ TxHash common.Hash Block‰∏≠‰∫§ÊòìÊ†ë ‚Äútx Trie‚ÄùÁöÑÊ†πËäÇÁÇπÁöÑRLPÂìàÂ∏åÂÄº„ÄÇBlockÁöÑÊàêÂëòÂèòÈáètransactions‰∏≠ÊâÄÊúâÁöÑtxÂØπË±°ÔºåË¢´ÈÄê‰∏™ÊèíÂÖ•‰∏Ä‰∏™MPTÁªìÊûÑÔºåÂΩ¢Êàê‚Äútx Trie‚Äù„ÄÇ ReceiptHash common.Hash ‚ÄúReceipt Trie‚ÄùÁöÑÊ†πËäÇÁÇπÁöÑRLPÂìàÂ∏åÂÄº„ÄÇBlockÁöÑÊâÄÊúâTransactionÊâßË°åÂÆåÂêé‰ºöÁîüÊàê‰∏Ä‰∏™ReceiptÊï∞ÁªÑÔºåËøô‰∏™Êï∞ÁªÑ‰∏≠ÁöÑÊâÄÊúâReceiptË¢´ÈÄê‰∏™ÊèíÂÖ•‰∏Ä‰∏™MPTÁªìÊûÑ‰∏≠ÔºåÊúÄÂêéÂΩ¢Êàê‚ÄùReceipt Trie‚Äù Bloom Bloom BloomËøáÊª§Âô®(Filter)ÔºåÁî®Êù•Âø´ÈÄüÂà§Êñ≠‰∏Ä‰∏™ÂèÇÊï∞LogÂØπË±°ÊòØÂê¶Â≠òÂú®‰∫é‰∏ÄÁªÑÂ∑≤Áü•ÁöÑLogÈõÜÂêà‰∏≠„ÄÇ Difficulty *big.Int Âå∫ÂùóÁöÑÈöæÂ∫¶„ÄÇBlockÁöÑDifficultyÁî±ÂÖ±ËØÜÁÆóÊ≥ïÂü∫‰∫éparentBlockÁöÑTimeÂíåDifficultyËÆ°ÁÆóÂæóÂá∫ÔºåÂÆÉ‰ºöÂ∫îÁî®Âú®Âå∫ÂùóÁöÑ‚ÄòÊåñÊéò‚ÄôÈò∂ÊÆµ„ÄÇ Number *big.Int Âå∫ÂùóÁöÑÂ∫èÂè∑„ÄÇBlockÁöÑNumberÁ≠â‰∫éÂÖ∂Áà∂Âå∫ÂùóNumber +1„ÄÇ GasLimit *big.Int Âå∫ÂùóÂÜÖÊâÄÊúâGasÊ∂àËÄóÁöÑ‰∏äÈôê„ÄÇËØ•Êï∞ÂÄºÂú®Âå∫ÂùóÂàõÂª∫Êó∂ËµãÂÄºÔºå‰∏éÁà∂Âå∫ÂùóÁöÑÊï∞ÊçÆÁõ∏ÂÖ≥„ÄÇÂÖ∑‰ΩìÊù•ËØ¥ÔºåÊ†πÊçÆÁà∂Âå∫ÂùóÁöÑGasUsedÂêåÂàõ‰∏ñÂùóÁöÑGasLimit * 2/3ÁöÑÂ§ßÂ∞èÂÖ≥Á≥ªÊù•ËÆ°ÁÆóÂæóÂá∫„ÄÇ GasUsed *big.Int Âå∫ÂùóÂÜÖÊâÄÊúâTransactionÊâßË°åÊó∂ÊâÄÂÆûÈôÖÊ∂àËÄóÁöÑGasÊÄªÂíå„ÄÇ Time *big.Int Âå∫Âùó‚ÄúÂ∫îËØ•‚ÄùË¢´ÂàõÂª∫ÁöÑÊó∂Èó¥„ÄÇÁî±ÂÖ±ËØÜÁÆóÊ≥ïÁ°ÆÂÆöÔºå‰∏ÄËà¨Êù•ËØ¥ÔºåË¶Å‰πàÁ≠â‰∫éparentBlock.Time + 10sÔºåË¶Å‰πàÁ≠â‰∫éÂΩìÂâçÁ≥ªÁªüÊó∂Èó¥„ÄÇÂå∫ÂùóÂºÄÂßãÊâìÂåÖÊó∂Èó¥Êà≥ÔºàË∞ÉÁî®Engine.PrepareÂáΩÊï∞ÁöÑÊó∂ÂÄôËÆæÁΩÆÔºâ Extra []byte Êâ©Â±ï‰ø°ÊÅØ MixDigest common.Hash Âå∫ÂùóÂ§¥Èô§ÂéªNonce, mixDigestÊï∞ÊçÆÁöÑhash+nonceÁöÑRLPÁöÑhashÂÄº Nonce BlockNonce ‰∏Ä‰∏™64bitÁöÑÂìàÂ∏åÊï∞ÔºåÂÆÉË¢´Áî®‰∫éPOWÁ≠âÊåñÂùóÁÆóÊ≥ïÔºåÊö¥ÂäõÁ¢∞ÊíûÂæóÂá∫,ËØ•ÂìàÂ∏åÂÄº‰∏éMixDigestÂìàÂ∏åÂÄº‰∏ÄËµ∑ËØÅÊòéËØ•Âå∫Âùó‰∏äÂ∑≤ÁªèËøõË°å‰∫ÜË∂≥Â§üÁöÑËÆ°ÁÆóÔºåÁî®‰∫éËØÅÊòéÊåñÁüøÊàêÂäü HardwareRandom []byte BOEÁ°¨‰ª∂ÈöèÊú∫Êï∞ 1234type Body struct &#123; Transactions []*Transaction Uncles []*Header&#125; Â≠óÊÆµ Á±ªÂûã Âê´‰πâ Â§áÊ≥® Transactions []*Transaction ‰∫§ÊòìÈõÜÂêà Uncles []*Header ÂèîÂå∫ÂùóÂ§¥ÈõÜÂêà 12345678type Transaction struct &#123; data txdata // caches hash atomic.Value size atomic.Value from atomic.Value fromP2P bool&#125; Â≠óÊÆµ Á±ªÂûã Âê´‰πâ Â§áÊ≥® data txdata ‰∫§ÊòìÊï∞ÊçÆ hash atomic.Value size atomic.Value from atomic.Value txÁöÑËΩ¨Â∏êËΩ¨Âá∫ÊñπÂú∞ÂùÄÔºåÂ∞±ÊòØÂØπËØ•txÂØπË±°‰ΩúECDSAÁ≠æÂêçËÆ°ÁÆóÊó∂ÊâÄÁî®ÁöÑÂÖ¨Èí•publicKey fromP2P bool 1234567891011121314type txdata struct &#123; AccountNonce uint64 `json:"nonce" gencodec:"required"` Price *big.Int `json:"gasPrice" gencodec:"required"` GasLimit *big.Int `json:"gas" gencodec:"required"` Recipient *common.Address `json:"to" rlp:"nil"` // nil means contract creation Amount *big.Int `json:"value" gencodec:"required"` Payload []byte `json:"input" gencodec:"required"` // Signature values V *big.Int `json:"v" gencodec:"required"` R *big.Int `json:"r" gencodec:"required"` S *big.Int `json:"s" gencodec:"required"` // This is only used when marshaling to JSON. Hash *common.Hash `json:"hash" rlp:"-"`&#125; Â≠óÊÆµ Á±ªÂûã Âê´‰πâ Â§áÊ≥® AccountNonce uint64 ÂèëÈÄÅËÄÖÂèëËµ∑ÁöÑ‰∫§ÊòìÊÄªÊï∞ Price *big.Int ‰∫§ÊòìÁöÑGas‰ª∑Ê†º GasLimit *big.Int ‰∫§ÊòìÂÖÅËÆ∏Ê∂àËÄóÁöÑÊúÄÂ§ßGas Recipient *common.Address ‰∫§ÊòìÊé•Êî∂ËÄÖÂú∞ÂùÄÔºå Amount *big.Int ‰∫§ÊòìÈ¢ù Payload []byte ÂÆÉÊó¢ÂèØ‰ª•‰Ωú‰∏∫ÊâÄÂàõÂª∫ÂêàÁ∫¶ÁöÑÊåá‰ª§Êï∞ÁªÑÔºåÂÖ∂‰∏≠ÊØè‰∏Ä‰∏™byte‰Ωú‰∏∫‰∏Ä‰∏™ÂçïÁã¨ÁöÑËôöÊãüÊú∫Êåá‰ª§Ôºõ‰πüÂèØ‰ª•‰Ωú‰∏∫Êï∞ÊçÆÊï∞ÁªÑÔºåÁî±ÂêàÁ∫¶Êåá‰ª§ËøõË°åÊìç‰Ωú„ÄÇÂêàÁ∫¶Áî±‰ª•Â§™ÂùäËôöÊãüÊú∫(Ethereum Virtual Machine, EVM)ÂàõÂª∫Âπ∂ÊâßË°å„ÄÇ V *big.Int txÁöÑÊï∞Â≠óÁ≠æÂêçÔºàECDSAÔºâ,ÊòØ‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫65bytesÁöÑÂ≠óËäÇÊï∞ÁªÑÔºåÂÆÉË¢´Êà™Êàê‰∏âÊÆµÊîæËøõtx‰∏≠ÔºåÂâç32bytesËµãÂÄºÁªôÊàêÂëòÂèòÈáèR, ÂÜç32bytesËµãÂÄºÁªôSÔºåÊú´1byteËµãÁªôV R *big.Int Âêå‰∏ä S *big.Int Âêå‰∏ä Hash *common.Hash ‰∫§ÊòìHAshÔºåÂè™Âú®JSONËΩ¨Êç¢Êó∂‰ΩøÁî® ‰ª•‰∏ä‰æøÊòØÂå∫ÂùóÈìæ‰∏≠ÊúÄ‰∏ªË¶ÅÁöÑ‚ÄúÂå∫ÂùóÈìæ‚ÄùÊï∞ÊçÆÁªìÊûÑÔºåÊúâ‰∫õÂ≠óÊÆµÊèèËø∞‰∏çÊòØÂæàÊ∏ÖÊ•öÔºåÂêéÁª≠ÂÜçÈÄêÊ≠•ÂÆåÂñÑ„ÄÇ]]></content>
      <categories>
        <category>HPBÊ∫êÁ†ÅËß£ËØª</category>
      </categories>
      <tags>
        <tag>HPB</tag>
        <tag>Âå∫ÂùóÈìæ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GO-HPBÊ∫êÁ†ÅËß£ËØª--ËäÇÁÇπÂàùÂßãÂåñ]]></title>
    <url>%2F2019%2F07%2F21%2FGO-HPB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E8%8A%82%E7%82%B9%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[HPBÂú®ÂàõÂª∫Â∏êÂè∑Êó∂‰ΩøÁî®ÁöÑÂëΩ‰ª§ÊòØ ./ghpb --datadir node/data init gensis.jsonÈÄöËøá‰ª£Á†ÅÁúã‰∏ãËäÇÁÇπÂàùÂßãÂåñÂÅö‰∫Ü‰ªÄ‰πà‰∫ãÊÉÖ initÂëΩ‰ª§ÂÆö‰πâÂú®chaincmd.goÊñá‰ª∂‰∏≠ÔºåÂÖ≥‰∫éurfaveÂíåutils.MigrateFlagsÂú®ÂàõÂª∫Â∏êÂè∑‰∏≠ÂÅöËøáËØ¥ÊòéÔºåËøôÈáåÁõ¥Êé•Áúã‰∏ãinitGenesisÂÅö‰∫Ü‰ªÄ‰πà‰∫ãÊÉÖ„ÄÇ initGenesisÊñπÊ≥ïÊµÅÁ®ãÔºö MakeConfigNodeÊñπÊ≥ïÈÖçÁΩÆËäÇÁÇπÁöÑÈªòËÆ§ÂèÇÊï∞‰ø°ÊÅØÔºåËøô‰∏™Êó∂ÂÄôÂ¶ÇÊûúÂæàÂ§öÂèÇÊï∞Ê≤°ÊúâÈÄöËøáÂëΩ‰ª§ÂæàËæìÂÖ•ËøõÊù•ÔºåÁ®ãÂ∫è‰ºöÊääÊâÄÊúâÁöÑÂèÇÊï∞‰ø°ÊÅØËÆæÁΩÆ‰∏∫ÈªòËÆ§ÂÄº Âä†ËΩΩÊñá‰ª∂gensis.jsonÊñá‰ª∂ÔºåÊñá‰ª∂ÂêçÈÄöËøáinitÁöÑflagÂèÇÊï∞ËæìÂÖ•ËøõË°å„ÄÇÂêéËæπÊàë‰ª¨ÂØπgensis.jsonÊñá‰ª∂Ëß£ËØª‰∏Ä‰∏ã„ÄÇ ÂàõÂª∫bc.GenesisÂØπË±°ÔºåÁÑ∂ÂêéÈÄöËøágensis.jsonÊñá‰ª∂ÁöÑ‰ø°ÊÅØËøõË°åËµãÂÄº db.OpenDatabaseÂàõÂª∫Êï∞ÊçÆÂ∫ì bc.SetupGenesisBlockfËøõË°åÂàùÂßãÂùóÁöÑÁîüÊàêÂíåÂÜôÂÖ•Êñá‰ª∂ github.com\hpb-project\go-hpb\cmd\chaincmd.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 initCommand = cli.Command&#123; Action: utils.MigrateFlags(initGenesis), Name: "init", Usage: "Bootstrap and initialize a new genesis block", ArgsUsage: "&lt;genesisPath&gt;", Flags: []cli.Flag&#123; utils.DataDirFlag, utils.LightModeFlag, &#125;, Category: "BLOCKCHAIN COMMANDS", Description: ``, &#125; // initGenesis will initialise the given JSON format genesis file and writes it as// the zero'd block (i.e. genesis) or will fail hard if it can't succeed.func initGenesis(ctx *cli.Context) error &#123; // Open an initialise both full and light databases //stack, _ := MakeConfigNode(ctx) MakeConfigNode(ctx) // Make sure we have a valid genesis JSON genesisPath := ctx.Args().First() if len(genesisPath) == 0 &#123; utils.Fatalf("Must supply path to genesis JSON file") &#125; file, err := os.Open(genesisPath) if err != nil &#123; log.Warn("genesis path is %s", genesisPath) utils.Fatalf("Failed to read genesis file: %v", err) &#125; defer file.Close() genesis := new(bc.Genesis) if err := json.NewDecoder(file).Decode(genesis); err != nil &#123; utils.Fatalf("invalid genesis file: %v", err) &#125; for _, name := range []string&#123;"chaindata"&#125; &#123; chaindb, err := db.OpenDatabase(name, 0, 0) if err != nil &#123; utils.Fatalf("Failed to open database: %v", err) &#125; _, hash, err := bc.SetupGenesisBlock(chaindb, genesis) if err != nil &#123; utils.Fatalf("Failed to write genesis block: %v", err) &#125; log.Info("Successfully wrote genesis state", "database", name, "hash", hash) &#125; return nil&#125; Áúã‰∏ãÂàõÂª∫Êï∞ÊçÆÂ∫ìÁöÑ‰ª£Á†ÅÔºåÊï∞ÊçÆÂ∫ìÂÆû‰æãÈÄöËøáatomic.Value{}Êù•ÂÆûÁé∞Á∫øÁ®ãÂÆâÂÖ®Êìç‰Ωú„ÄÇÂΩìÊ≤°Êúâ‰º†ÂÖ•‚ÄìdatadirÂèÇÊï∞Êó∂Ôºå‰ºöÁõ¥Êé•ËøîÂõûÂÜÖÂ≠òÊï∞ÊçÆÂ∫ì,Âê¶Âàô‰ºöÂàõÂª∫chaindataÊï∞ÊçÆÂ∫ìÊñá‰ª∂„ÄÇResolvePathÊñπÊ≥ï‰ºöÂú®chaindataË∑ØÂæÑÂâçÂä†‰∏™ghpbË∑ØÂæÑ„ÄÇÊï∞ÊçÆÂ∫ì‰ΩøÁî®ÁöÑÊòØGoogleÁöÑlevelDB, 123456789101112131415161718192021// OpenDatabase opens an existing database with the given name (or creates one// if no previous can be found) from within the node's data directory. If the// node is an ephemeral one, a memory database is returned.func OpenDatabase(name string, cache int, handles int) (hpbdb.Database, error) &#123; if DBINSTANCE.Load() != nil &#123; return DBINSTANCE.Load().(*hpbdb.LDBDatabase),nil &#125; var cfg = config.GetHpbConfigInstance() if cfg.Node.DataDir == ""&#123; return hpbdb.NewMemDatabase() &#125; db, err := hpbdb.NewLDBDatabase(cfg.Node.ResolvePath(name), cache, handles) if err != nil &#123; return nil, err &#125; DBINSTANCE.Store(db) return db, nil&#125; SetupGenesisBlockÊñπÊ≥ï‰∏ªË¶ÅÊòØÂØπÂàùÂßãÂå∫ÂùóÁöÑÊñá‰ª∂ÂÜôÂÖ•„ÄÇ GetCanonicalHash(db, 0)È¶ñÂÖà‰ªéÊï∞ÊçÆÂ∫ìËé∑ÂèñÁ¨¨0‰∏™hashÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàôËøîÂõû‰∏Ä‰∏™ÂàùÂßãhashÔºåÂç≥[32]byte{0} ÊääÂàùÂßãÁöÑgenesis‰ø°ÊÅØÁîüÊàêÂàùÂßãÂå∫ÂùóÊèê‰∫§Âà∞Êï∞ÊçÆÂ∫ì ‚Ä¶ ‚Ä¶ ‚Ä¶ÂêéÁª≠ÂÜçËØª 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758func SetupGenesisBlock(db hpbdb.Database, genesis *Genesis) (*config.ChainConfig, common.Hash, error) &#123; if genesis != nil &amp;&amp; genesis.Config == nil &#123; return config.MainnetChainConfig, common.Hash&#123;&#125;, errGenesisNoConfig &#125; // Just commit the new block if there is no stored genesis block. stored := GetCanonicalHash(db, 0) if (stored == common.Hash&#123;&#125;) &#123; if genesis == nil &#123; genesis = DefaultGenesisBlock() &#125; else &#123; log.Info("Writing custom genesis block") &#125; block, err := genesis.Commit(db) return genesis.Config, block.Hash(), err &#125; // Check whether the genesis block is already written. if genesis != nil &#123; block, _ := genesis.ToBlock() hash := block.Hash() if hash != stored &#123; return genesis.Config, block.Hash(), &amp;GenesisMismatchError&#123;stored, hash&#125; &#125; &#125; // Get the existing chain configuration. newcfg := genesis.configOrDefault(stored) storedcfg, err := GetChainConfig(db, stored) if err != nil &#123; if err == ErrChainConfigNotFound &#123; // This case happens if a genesis write was interrupted. log.Warn("Found genesis block without chain config") err = WriteChainConfig(db, stored, newcfg) &#125; return newcfg, stored, err &#125; // Special case: don't change the existing config of a non-mainnet chain if no new // config is supplied. These chains would get AllProtocolChanges (and a compat error) // if we just continued here. if genesis == nil &amp;&amp; stored != config.MainnetGenesisHash &#123; return storedcfg, stored, nil &#125; // Check config compatibility and write the config. Compatibility errors // are returned to the caller unless we're already at block zero. height := GetBlockNumber(db, GetHeadHeaderHash(db)) if height == missingNumber &#123; return newcfg, stored, fmt.Errorf("missing block number for head header hash") &#125; compatErr := storedcfg.CheckCompatible(newcfg, height) if compatErr != nil &amp;&amp; height != 0 &amp;&amp; compatErr.RewindTo != 0 &#123; return newcfg, stored, compatErr &#125; return newcfg, stored, WriteChainConfig(db, stored, newcfg)&#125; genesis.Commit(db)ÊñπÊ≥ï‰∏≠ÔºåÈ¶ñÂÖàÂ∞ÜgenesisËΩ¨ÂåñÊàê‰∏Ä‰∏™Âå∫ÂùóÔºåÁÑ∂ÂêéÂÜçÂ∞ÜÂå∫Âùó‰ø°ÊÅØÂÜôÂÖ•Êï∞ÊçÆÂ∫ìÔºåÂêåÊó∂ÂåÖÂê´ÂÖ∂‰ªñ‰∏Ä‰∫õÊï∞ÊçÆÂÜÖÂÆπÔºåÊØîÂ¶ÇblockReceipts„ÄÅGetCanonicalHash,WriteHeadBlockHashÁ≠âÁ≠â„ÄÇÊ≠§Êó∂Â∑≤Êé•Ëß¶Âà∞ÂàùÂßãblockÔºåÂêéÁª≠ÊñáÁ´†Êàë‰ª¨ÂØπÁõ∏ÂÖ≥Êï∞ÊçÆÁªìÊûÑËøõË°åËØ¶ÁªÜËØ¥Êòé 1234567891011121314151617181920212223242526272829303132333435// Commit writes the block and state of a genesis specification to the database.// The block is committed as the canonical head block.func (g *Genesis) Commit(db hpbdb.Database) (*types.Block, error) &#123; block, statedb := g.ToBlock() if block.Number().Sign() != 0 &#123; return nil, fmt.Errorf("can't commit genesis block with number &gt; 0") &#125; if _, err := statedb.CommitTo(db, false); err != nil &#123; return nil, fmt.Errorf("cannot write state: %v", err) &#125; if err := WriteTd(db, block.Hash(), block.NumberU64(), g.Difficulty); err != nil &#123; return nil, err &#125; if err := WriteBlock(db, block); err != nil &#123; return nil, err &#125; if err := WriteBlockReceipts(db, block.Hash(), block.NumberU64(), nil); err != nil &#123; return nil, err &#125; if err := WriteCanonicalHash(db, block.Hash(), block.NumberU64()); err != nil &#123; return nil, err &#125; if err := WriteHeadBlockHash(db, block.Hash()); err != nil &#123; return nil, err &#125; if err := WriteHeadHeaderHash(db, block.Hash()); err != nil &#123; return nil, err &#125; configtemp := g.Config if configtemp == nil &#123; configtemp = config.MainnetChainConfig &#125; return block, WriteChainConfig(db, block.Hash(), configtemp)&#125;]]></content>
      <categories>
        <category>HPBÊ∫êÁ†ÅËß£ËØª</category>
      </categories>
      <tags>
        <tag>HPB</tag>
        <tag>Âå∫ÂùóÈìæ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GO-HPBÊ∫êÁ†ÅËß£ËØª--ÂàõÂª∫Â∏êÂè∑]]></title>
    <url>%2F2019%2F07%2F21%2FGO-HPB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E5%88%9B%E5%BB%BA%E5%B8%90%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[HPBÂú®ÂàõÂª∫Â∏êÂè∑Êó∂‰ΩøÁî®ÁöÑÂëΩ‰ª§ÊòØ ./ghpb --datadir node/data account initÈÄöËøá‰ª£Á†ÅÁúã‰∏ãÂàõÂª∫ÊµÅÁ®ã go-hpbÊ∫êÁ†ÅÂëΩ‰ª§Êû∂ÊûÑ‰ΩøÁî®ÁöÑÊòØurfave/cliÔºå‰∏çÁü•ÈÅìÊòØ‰∏çÊòØËøôÊ†∑ËØªËøô‰∏™ÂêçÁß∞Ôºöyou are Â∫üÁâ©ÔºåËøôÈáåÊúâ‰∏™‰∏çÈîôÁöÑÂ∏ñÂ≠ê‰ªãÁªçÔºåÂèØ‰ª•Â≠¶‰π†‰∏ã„ÄÇ‰∏ªË¶ÅÂØπÂëΩ‰ª§ËøõË°å‰∫ÜÂ∞ÅË£ÖÔºåÊàë‰ª¨‰∏ªË¶ÅÂÖ≥ÂøÉÂëΩ‰ª§ÊâÄÂØπÂ∫îÁöÑ‰∏öÂä°ÂÆûÁé∞ÈÄªËæëÂç≥ÂèØÔºå‰ΩøÁî®Ëµ∑Êù•ÈùûÂ∏∏Êñπ‰æø„ÄÇÈòÖËØª‰πü‰ªéËøô‰∏™Âú∞ÊñπÂºÄÂßã„ÄÇ accountÂëΩ‰ª§ÂÆö‰πâÂú®accountcmd.goÊñá‰ª∂‰∏≠ÔºåÈÄöËøáÊ∫êÁ†ÅÂèØ‰ª•ÁúãÂà∞accountÂëΩ‰ª§Êúâlist„ÄÅnew„ÄÅupdate„ÄÅimportÂõõ‰∏™Â≠êÂëΩ‰ª§„ÄÇÊØè‰∏Ä‰∏™ÂëΩ‰ª§ÈÉΩÊúâflagsÂèÇÊï∞„ÄÇ github.com\hpb-project\go-hpb\cmd\accountcmd.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556accountCommand = cli.Command&#123; Name: "account", Usage: "Manage accounts", Category: "ACCOUNT COMMANDS", Description: ``, Subcommands: []cli.Command&#123; &#123; Name: "list", Usage: "Print summary of existing accounts", Action: utils.MigrateFlags(accountList), Flags: []cli.Flag&#123; utils.DataDirFlag, utils.KeyStoreDirFlag, &#125;, Description: `Print a short summary of all accounts`, &#125;, &#123; Name: "new", Usage: "Create a new account", Action: utils.MigrateFlags(accountCreate), Flags: []cli.Flag&#123; utils.DataDirFlag, utils.KeyStoreDirFlag, utils.PasswordFileFlag, utils.LightKDFFlag, &#125;, Description: ``, &#125;, &#123; Name: "update", Usage: "Update an existing account", Action: utils.MigrateFlags(accountUpdate), ArgsUsage: "&lt;address&gt;", Flags: []cli.Flag&#123; utils.DataDirFlag, utils.KeyStoreDirFlag, utils.LightKDFFlag, &#125;, Description: ``, &#125;, &#123; Name: "import", Usage: "Import a private key into a new account", Action: utils.MigrateFlags(accountImport), Flags: []cli.Flag&#123; utils.DataDirFlag, utils.KeyStoreDirFlag, utils.PasswordFileFlag, utils.LightKDFFlag, &#125;, ArgsUsage: "&lt;keyFile&gt;", Description: `, &#125;, &#125;, &#125;) Áé∞Âú®‰∏ªË¶ÅÁúã‰∏Ä‰∏ãnewËøô‰∏™Â≠êÂëΩ‰ª§ÔºåActionÂ±ûÊÄß‰∏ªË¶ÅÁî®Êù•ÊåáÂÆönewÂëΩ‰ª§ÁöÑÊâÄÈúÄË¶ÅÊâßË°åÁöÑÂä®‰Ωú„ÄÇËøôÈáåÂèØ‰ª•ÁúãÂà∞ÊòØutils.MigrateFlags(accountCreate)Ôºå MigrateFlagsÊñπÊ≥ïÊòØÊääaccountÂëΩ‰ª§ÁöÑflagÂèÇÊï∞ËÆæÁΩÆÂà∞ÂÖ®Â±ÄÂèÇÊï∞Èáå„ÄÇÊØîÂ¶ÇÂëΩ‰ª§hpb account new ‚Äìkeystore /tmp/mykeystore ‚ÄìlightkdfÊòØÁ≠â‰ª∑‰∫éhpb ‚Äìkeystore /tmp/mykeystore ‚Äìlightkdf account new„ÄÇ‰∏ªË¶ÅÁöÑ‰∏öÂä°ÂÆûÁé∞ÈúÄË¶ÅÊü•ÁúãaccountCreate 123456789101112&#123; Name: "new", Usage: "Create a new account", Action: utils.MigrateFlags(accountCreate), Flags: []cli.Flag&#123; utils.DataDirFlag, utils.KeyStoreDirFlag, utils.PasswordFileFlag, utils.LightKDFFlag, &#125;, Description: ``,&#125;, accountCreateÊñπÊ≥ïÈ¶ñÂÖàÂàùÂßãÂåñËäÇÁÇπÈÖçÁΩÆÂØπË±°ÔºåÂπ∂ÂÆû‰æãÂåñ‰∏Ä‰∏ãËäÇÁÇπÂØπË±°,getPassPhraseÊé•Êî∂‰∏Ä‰∏™Áî®Êà∑ËæìÂÖ•ÁöÑÂè£‰ª§„ÄÇÊé•‰∏ãÊù•ÈÄöËøáÂè£‰ª§ÂèÇÊï∞ÁîüÊàêÁî®Êà∑Â∏êÊà∑‰ø°ÊÅØ. 12345678910111213141516171819202122// accountCreate creates a new account into the keystore defined by the CLI flags.func accountCreate(ctx *cli.Context) error &#123; //ËøõË°åËäÇÁÇπÂèÇÊï∞ÈÖçÁΩÆ cfg := MakeConfigNode(ctx) //ÂàõÂª∫ËäÇÁÇπÂÆû‰æã stack, err := createNode(cfg) if err != nil &#123; utils.Fatalf("Failed to create node") return err &#125; //Êé•Êî∂Áî®Êà∑ËæìÂÖ•ÁöÑÂè£‰ª§ password := getPassPhrase("Your new account is locked with a password. Please give a password. Do not forget this password.", true, 0, utils.MakePasswordList(ctx)) //ÂàõÂª∫‰∏Ä‰∏™keyStore ks := stack.AccountManager().KeyStore().(*keystore.KeyStore) //‰ΩøÁî®Âè£‰ª§ÂØπkeyStore‰ø°ÊÅØËøõË°åÂä†ÂØÜÔºåÂπ∂ËøîÂõû‰∏Ä‰∏™Â∏êÊà∑Âú∞ÂùÄ account, err := ks.NewAccount(password) if err != nil &#123; utils.Fatalf("Failed to create account: %v", err) &#125; fmt.Printf("Address: &#123;%x&#125;\n", account.Address) return nil&#125; NewAccountÊñπÊ≥ïÁî®Êù•ÁîüÊàê‰∏Ä‰∏™ÂØÜÈí•ÔºåÂπ∂Êää‰ªñ‰øùÂ≠òÂú®Êñá‰ª∂‰∏≠Ôºå‰πüÂ∞±ÊòØÂëΩ‰ª§ÊâßË°åÂêéÁîüÊàêÁöÑÊñá‰ª∂ÔºåÊØîÂ¶Çnode/data/keystore/UTC‚Äì2018-11-25T14-05-44.446434210Z‚Äìa0603b3443c89a6e2eff7614acec5a59f9f70ebb„ÄÇÁîüÊàê‰πãÂêéËøîÂõûÁöÑaccountÈúÄË¶ÅÂä†ËΩΩÂà∞ÂΩìÂâçcacheÈáåÔºåÂπ∂Âà∑Êñ∞wallet‰ø°ÊÅØ 1234567891011121314// NewAccount generates a new key and stores it into the key directory,// encrypting it with the passphrase.func (ks *KeyStore) NewAccount(passphrase string) (accounts.Account, error) &#123; _, account, err := storeNewKey(ks.storage, crand.Reader, passphrase) if err != nil &#123; return accounts.Account&#123;&#125;, err &#125; // Add the account to the cache immediately rather // than waiting for file system notifications to pick it up. ks.cache.add(account) ks.refreshWallets() return account, nil&#125; ÂÖ≥ÈîÆÊñπÊ≥ïstoreNewKeyÔºåÁ¨¨‰∏ÄÊ≠•newKey‰ºöÈöèÊú∫ÁîüÊàêÈùûÂØπÁß∞ÂØÜÈí•Ôºå‰ΩøÁî®ÁöÑÊòØÂ§ßÂêçÈ°∂È°∂ÁöÑECDSAÁÆóÊ≥ï„ÄÇÁÑ∂ÂêéÂàõÂª∫ ‰∏Ä‰∏™accountÂØπË±°ÔºåÂπ∂ËøõË°å‰øùÂ≠ò„ÄÇ‰øùÂ≠òÂÆåÊàêÈúÄË¶ÅÊääÂΩìÂâçÂÜÖÂ≠ò‰ø°ÊÅØËøõË°åÊ∏ÖÈô§Ôºå‰ª•Èò≤ÂÆâÂÖ®ÈöêÊÇ£„ÄÇ 123456789101112func storeNewKey(ks keyStore, rand io.Reader, auth string) (*Key, accounts.Account, error) &#123; key, err := newKey(rand) if err != nil &#123; return nil, accounts.Account&#123;&#125;, err &#125; a := accounts.Account&#123;Address: key.Address, URL: accounts.URL&#123;Scheme: KeyStoreScheme, Path: ks.JoinPath(keyFileName(key.Address))&#125;&#125; if err := ks.StoreKey(a.URL.Path, key, auth); err != nil &#123; zeroKey(key.PrivateKey) return nil, a, err &#125; return key, a, err&#125; newKeyÊñπÊ≥ïÁîüÊàêÈùûÂØπÁß∞ÂØÜÈí•ÔºåÂπ∂ËΩ¨Êàê‰∏Ä‰∏™Áî®Êà∑Â∏êÊà∑‰ø°ÊÅØÔºå‰∏ªË¶ÅÊòØÈúÄË¶ÅÈÄöËøáÂÖ¨Èí•ÁîüÊàê‰∏Ä‰∏™Áî®Êà∑Â∏êÊà∑Âú∞ÂùÄÔºåÂú®newKeyFromECDSAÊñπÊ≥ïÈáåÔºåÂèØ‰ª•ÁúãÂà∞ÁöÑÊòØECDSA.PublicKeyÁîüÊàêAddress 1234567891011121314151617func newKey(rand io.Reader) (*Key, error) &#123; privateKeyECDSA, err := ecdsa.GenerateKey(crypto.S256(), rand) if err != nil &#123; return nil, err &#125; return newKeyFromECDSA(privateKeyECDSA), nil&#125;func newKeyFromECDSA(privateKeyECDSA *ecdsa.PrivateKey) *Key &#123; id := uuid.NewRandom() key := &amp;Key&#123; Id: id, Address: crypto.PubkeyToAddress(privateKeyECDSA.PublicKey), PrivateKey: privateKeyECDSA, &#125; return key&#125; StoreKey‰∏ªË¶ÅÂÆåÊàêÈùûÂØπÁß∞ÂØÜÈí•ÈÄöËøáÁî®Êà∑ËæìÂÖ•Âè£‰ª§ËøõË°åÂä†ÂØÜ‰øùÂ≠òÂà∞Êñá‰ª∂ 1234567func (ks keyStorePassphrase) StoreKey(filename string, key *Key, auth string) error &#123; keyjson, err := EncryptKey(key, auth, ks.scryptN, ks.scryptP) if err != nil &#123; return err &#125; return writeKeyFile(filename, keyjson)&#125; Êñá‰ª∂‰øùÂ≠òÂêéÔºå‰∏öÂä°Â∞±Âü∫Êú¨ÂÆåÊàêÔºåÁ®ãÂ∫èÈÄÄÂá∫ÊâßË°å„ÄÇ]]></content>
      <categories>
        <category>HPBÊ∫êÁ†ÅËß£ËØª</category>
      </categories>
      <tags>
        <tag>HPB</tag>
        <tag>Âå∫ÂùóÈìæ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[ÊëòË¶ÅÊòæÁ§∫ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
